// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_RESOURCE_FLAT_RESOURCES_H_
#define FLATBUFFERS_GENERATED_RESOURCE_FLAT_RESOURCES_H_

#include "flatbuffers/flatbuffers.h"

#include "math-flat.hpp"

namespace flat {
namespace resources {

struct PropertyF;
struct PropertyFBuilder;

struct ObjectF;
struct ObjectFBuilder;

struct ObjectLayerF;
struct ObjectLayerFBuilder;

struct TileRefF;

struct TileLayerF;
struct TileLayerFBuilder;

struct LevelLayerF;
struct LevelLayerFBuilder;

struct LevelTilesetDepF;
struct LevelTilesetDepFBuilder;

struct LevelAssetF;
struct LevelAssetFBuilder;

struct TileShapeF;

struct TileF;

struct TileDataF;

struct TilesetLogicF;
struct TilesetLogicFBuilder;

struct TilesetAssetF;
struct TilesetAssetFBuilder;

struct AnimationAssetF;
struct AnimationAssetFBuilder;

struct SpriteAssetF;
struct SpriteAssetFBuilder;

struct ResourcesF;
struct ResourcesFBuilder;

enum AnyLayerF {
  AnyLayerF_NONE = 0,
  AnyLayerF_TileLayerF = 1,
  AnyLayerF_ObjectLayerF = 2,
  AnyLayerF_MIN = AnyLayerF_NONE,
  AnyLayerF_MAX = AnyLayerF_ObjectLayerF
};

inline const AnyLayerF (&EnumValuesAnyLayerF())[3] {
  static const AnyLayerF values[] = {
    AnyLayerF_NONE,
    AnyLayerF_TileLayerF,
    AnyLayerF_ObjectLayerF
  };
  return values;
}

inline const char * const *EnumNamesAnyLayerF() {
  static const char * const names[4] = {
    "NONE",
    "TileLayerF",
    "ObjectLayerF",
    nullptr
  };
  return names;
}

inline const char *EnumNameAnyLayerF(AnyLayerF e) {
  if (flatbuffers::IsOutRange(e, AnyLayerF_NONE, AnyLayerF_ObjectLayerF)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAnyLayerF()[index];
}

template<typename T> struct AnyLayerFTraits {
  static const AnyLayerF enum_value = AnyLayerF_NONE;
};

template<> struct AnyLayerFTraits<flat::resources::TileLayerF> {
  static const AnyLayerF enum_value = AnyLayerF_TileLayerF;
};

template<> struct AnyLayerFTraits<flat::resources::ObjectLayerF> {
  static const AnyLayerF enum_value = AnyLayerF_ObjectLayerF;
};

bool VerifyAnyLayerF(flatbuffers::Verifier &verifier, const void *obj, AnyLayerF type);
bool VerifyAnyLayerFVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) TileRefF FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t gid_;
  flat::math::Vec2Fu tilePos_;
  flat::math::Vec2Fu texPos_;

 public:
  TileRefF() {
    memset(static_cast<void *>(this), 0, sizeof(TileRefF));
  }
  TileRefF(uint32_t _gid, const flat::math::Vec2Fu &_tilePos, const flat::math::Vec2Fu &_texPos)
      : gid_(flatbuffers::EndianScalar(_gid)),
        tilePos_(_tilePos),
        texPos_(_texPos) {
  }
  uint32_t gid() const {
    return flatbuffers::EndianScalar(gid_);
  }
  const flat::math::Vec2Fu &tilePos() const {
    return tilePos_;
  }
  const flat::math::Vec2Fu &texPos() const {
    return texPos_;
  }
};
FLATBUFFERS_STRUCT_END(TileRefF, 20);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) TileShapeF FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t type_;
  uint32_t shapeTouches_;
  uint8_t hflip_;
  uint8_t vflip_;
  int16_t padding0__;

 public:
  TileShapeF() {
    memset(static_cast<void *>(this), 0, sizeof(TileShapeF));
  }
  TileShapeF(uint32_t _type, uint32_t _shapeTouches, bool _hflip, bool _vflip)
      : type_(flatbuffers::EndianScalar(_type)),
        shapeTouches_(flatbuffers::EndianScalar(_shapeTouches)),
        hflip_(flatbuffers::EndianScalar(static_cast<uint8_t>(_hflip))),
        vflip_(flatbuffers::EndianScalar(static_cast<uint8_t>(_vflip))),
        padding0__(0) {
    (void)padding0__;
  }
  uint32_t type() const {
    return flatbuffers::EndianScalar(type_);
  }
  uint32_t shapeTouches() const {
    return flatbuffers::EndianScalar(shapeTouches_);
  }
  bool hflip() const {
    return flatbuffers::EndianScalar(hflip_) != 0;
  }
  bool vflip() const {
    return flatbuffers::EndianScalar(vflip_) != 0;
  }
};
FLATBUFFERS_STRUCT_END(TileShapeF, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) TileF FLATBUFFERS_FINAL_CLASS {
 private:
  flat::math::Vec2Fu pos_;
  flat::resources::TileShapeF shape_;
  uint8_t facing_;
  int8_t padding0__;  int16_t padding1__;
  flat::math::Vec2Fi next_offset_;
  int32_t next_tilesetNdx_;

 public:
  TileF() {
    memset(static_cast<void *>(this), 0, sizeof(TileF));
  }
  TileF(const flat::math::Vec2Fu &_pos, const flat::resources::TileShapeF &_shape, flat::math::CardinalF _facing, const flat::math::Vec2Fi &_next_offset, int32_t _next_tilesetNdx)
      : pos_(_pos),
        shape_(_shape),
        facing_(flatbuffers::EndianScalar(static_cast<uint8_t>(_facing))),
        padding0__(0),
        padding1__(0),
        next_offset_(_next_offset),
        next_tilesetNdx_(flatbuffers::EndianScalar(_next_tilesetNdx)) {
    (void)padding0__;    (void)padding1__;
  }
  const flat::math::Vec2Fu &pos() const {
    return pos_;
  }
  const flat::resources::TileShapeF &shape() const {
    return shape_;
  }
  flat::math::CardinalF facing() const {
    return static_cast<flat::math::CardinalF>(flatbuffers::EndianScalar(facing_));
  }
  const flat::math::Vec2Fi &next_offset() const {
    return next_offset_;
  }
  int32_t next_tilesetNdx() const {
    return flatbuffers::EndianScalar(next_tilesetNdx_);
  }
};
FLATBUFFERS_STRUCT_END(TileF, 36);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) TileDataF FLATBUFFERS_FINAL_CLASS {
 private:
  flat::resources::TileF tile_;
  uint8_t has_prop_bits_;
  int8_t padding0__;  int16_t padding1__;
  uint32_t logic_ndx_;
  uint32_t logic_arg_ndx_;
  uint32_t material_ndx_;

 public:
  TileDataF() {
    memset(static_cast<void *>(this), 0, sizeof(TileDataF));
  }
  TileDataF(const flat::resources::TileF &_tile, uint8_t _has_prop_bits, uint32_t _logic_ndx, uint32_t _logic_arg_ndx, uint32_t _material_ndx)
      : tile_(_tile),
        has_prop_bits_(flatbuffers::EndianScalar(_has_prop_bits)),
        padding0__(0),
        padding1__(0),
        logic_ndx_(flatbuffers::EndianScalar(_logic_ndx)),
        logic_arg_ndx_(flatbuffers::EndianScalar(_logic_arg_ndx)),
        material_ndx_(flatbuffers::EndianScalar(_material_ndx)) {
    (void)padding0__;    (void)padding1__;
  }
  const flat::resources::TileF &tile() const {
    return tile_;
  }
  uint8_t has_prop_bits() const {
    return flatbuffers::EndianScalar(has_prop_bits_);
  }
  uint32_t logic_ndx() const {
    return flatbuffers::EndianScalar(logic_ndx_);
  }
  uint32_t logic_arg_ndx() const {
    return flatbuffers::EndianScalar(logic_arg_ndx_);
  }
  uint32_t material_ndx() const {
    return flatbuffers::EndianScalar(material_ndx_);
  }
};
FLATBUFFERS_STRUCT_END(TileDataF, 52);

struct PropertyF FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PropertyFBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PROPERTYNAME = 4,
    VT_PROPERTYVALUE = 6
  };
  const flatbuffers::String *propertyName() const {
    return GetPointer<const flatbuffers::String *>(VT_PROPERTYNAME);
  }
  const flatbuffers::String *propertyValue() const {
    return GetPointer<const flatbuffers::String *>(VT_PROPERTYVALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PROPERTYNAME) &&
           verifier.VerifyString(propertyName()) &&
           VerifyOffset(verifier, VT_PROPERTYVALUE) &&
           verifier.VerifyString(propertyValue()) &&
           verifier.EndTable();
  }
};

struct PropertyFBuilder {
  typedef PropertyF Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_propertyName(flatbuffers::Offset<flatbuffers::String> propertyName) {
    fbb_.AddOffset(PropertyF::VT_PROPERTYNAME, propertyName);
  }
  void add_propertyValue(flatbuffers::Offset<flatbuffers::String> propertyValue) {
    fbb_.AddOffset(PropertyF::VT_PROPERTYVALUE, propertyValue);
  }
  explicit PropertyFBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PropertyFBuilder &operator=(const PropertyFBuilder &);
  flatbuffers::Offset<PropertyF> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PropertyF>(end);
    return o;
  }
};

inline flatbuffers::Offset<PropertyF> CreatePropertyF(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> propertyName = 0,
    flatbuffers::Offset<flatbuffers::String> propertyValue = 0) {
  PropertyFBuilder builder_(_fbb);
  builder_.add_propertyValue(propertyValue);
  builder_.add_propertyName(propertyName);
  return builder_.Finish();
}

inline flatbuffers::Offset<PropertyF> CreatePropertyFDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *propertyName = nullptr,
    const char *propertyValue = nullptr) {
  auto propertyName__ = propertyName ? _fbb.CreateString(propertyName) : 0;
  auto propertyValue__ = propertyValue ? _fbb.CreateString(propertyValue) : 0;
  return flat::resources::CreatePropertyF(
      _fbb,
      propertyName__,
      propertyValue__);
}

struct ObjectF FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ObjectFBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_NAME = 6,
    VT_TYPE_HASH = 8,
    VT_POS = 10,
    VT_WIDTH = 12,
    VT_HEIGHT = 14,
    VT_PROPERTIES = 16,
    VT_POINTS = 18
  };
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  uint64_t type_hash() const {
    return GetField<uint64_t>(VT_TYPE_HASH, 0);
  }
  const flat::math::Vec2Fi *pos() const {
    return GetStruct<const flat::math::Vec2Fi *>(VT_POS);
  }
  uint32_t width() const {
    return GetField<uint32_t>(VT_WIDTH, 0);
  }
  uint32_t height() const {
    return GetField<uint32_t>(VT_HEIGHT, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flat::resources::PropertyF>> *properties() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flat::resources::PropertyF>> *>(VT_PROPERTIES);
  }
  const flatbuffers::Vector<const flat::math::Vec2Fi *> *points() const {
    return GetPointer<const flatbuffers::Vector<const flat::math::Vec2Fi *> *>(VT_POINTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint64_t>(verifier, VT_TYPE_HASH) &&
           VerifyFieldRequired<flat::math::Vec2Fi>(verifier, VT_POS) &&
           VerifyField<uint32_t>(verifier, VT_WIDTH) &&
           VerifyField<uint32_t>(verifier, VT_HEIGHT) &&
           VerifyOffset(verifier, VT_PROPERTIES) &&
           verifier.VerifyVector(properties()) &&
           verifier.VerifyVectorOfTables(properties()) &&
           VerifyOffset(verifier, VT_POINTS) &&
           verifier.VerifyVector(points()) &&
           verifier.EndTable();
  }
};

struct ObjectFBuilder {
  typedef ObjectF Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(ObjectF::VT_ID, id, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(ObjectF::VT_NAME, name);
  }
  void add_type_hash(uint64_t type_hash) {
    fbb_.AddElement<uint64_t>(ObjectF::VT_TYPE_HASH, type_hash, 0);
  }
  void add_pos(const flat::math::Vec2Fi *pos) {
    fbb_.AddStruct(ObjectF::VT_POS, pos);
  }
  void add_width(uint32_t width) {
    fbb_.AddElement<uint32_t>(ObjectF::VT_WIDTH, width, 0);
  }
  void add_height(uint32_t height) {
    fbb_.AddElement<uint32_t>(ObjectF::VT_HEIGHT, height, 0);
  }
  void add_properties(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::resources::PropertyF>>> properties) {
    fbb_.AddOffset(ObjectF::VT_PROPERTIES, properties);
  }
  void add_points(flatbuffers::Offset<flatbuffers::Vector<const flat::math::Vec2Fi *>> points) {
    fbb_.AddOffset(ObjectF::VT_POINTS, points);
  }
  explicit ObjectFBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ObjectFBuilder &operator=(const ObjectFBuilder &);
  flatbuffers::Offset<ObjectF> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ObjectF>(end);
    fbb_.Required(o, ObjectF::VT_NAME);
    fbb_.Required(o, ObjectF::VT_POS);
    return o;
  }
};

inline flatbuffers::Offset<ObjectF> CreateObjectF(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    uint64_t type_hash = 0,
    const flat::math::Vec2Fi *pos = 0,
    uint32_t width = 0,
    uint32_t height = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::resources::PropertyF>>> properties = 0,
    flatbuffers::Offset<flatbuffers::Vector<const flat::math::Vec2Fi *>> points = 0) {
  ObjectFBuilder builder_(_fbb);
  builder_.add_type_hash(type_hash);
  builder_.add_points(points);
  builder_.add_properties(properties);
  builder_.add_height(height);
  builder_.add_width(width);
  builder_.add_pos(pos);
  builder_.add_name(name);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<ObjectF> CreateObjectFDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    const char *name = nullptr,
    uint64_t type_hash = 0,
    const flat::math::Vec2Fi *pos = 0,
    uint32_t width = 0,
    uint32_t height = 0,
    const std::vector<flatbuffers::Offset<flat::resources::PropertyF>> *properties = nullptr,
    const std::vector<flat::math::Vec2Fi> *points = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto properties__ = properties ? _fbb.CreateVector<flatbuffers::Offset<flat::resources::PropertyF>>(*properties) : 0;
  auto points__ = points ? _fbb.CreateVectorOfStructs<flat::math::Vec2Fi>(*points) : 0;
  return flat::resources::CreateObjectF(
      _fbb,
      id,
      name__,
      type_hash,
      pos,
      width,
      height,
      properties__,
      points__);
}

struct ObjectLayerF FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ObjectLayerFBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OBJECTS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<flat::resources::ObjectF>> *objects() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flat::resources::ObjectF>> *>(VT_OBJECTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_OBJECTS) &&
           verifier.VerifyVector(objects()) &&
           verifier.VerifyVectorOfTables(objects()) &&
           verifier.EndTable();
  }
};

struct ObjectLayerFBuilder {
  typedef ObjectLayerF Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objects(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::resources::ObjectF>>> objects) {
    fbb_.AddOffset(ObjectLayerF::VT_OBJECTS, objects);
  }
  explicit ObjectLayerFBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ObjectLayerFBuilder &operator=(const ObjectLayerFBuilder &);
  flatbuffers::Offset<ObjectLayerF> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ObjectLayerF>(end);
    return o;
  }
};

inline flatbuffers::Offset<ObjectLayerF> CreateObjectLayerF(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::resources::ObjectF>>> objects = 0) {
  ObjectLayerFBuilder builder_(_fbb);
  builder_.add_objects(objects);
  return builder_.Finish();
}

inline flatbuffers::Offset<ObjectLayerF> CreateObjectLayerFDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<flat::resources::ObjectF>> *objects = nullptr) {
  auto objects__ = objects ? _fbb.CreateVector<flatbuffers::Offset<flat::resources::ObjectF>>(*objects) : 0;
  return flat::resources::CreateObjectLayerF(
      _fbb,
      objects__);
}

struct TileLayerF FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TileLayerFBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HAS_PARALLAX = 4,
    VT_HAS_SCROLL = 6,
    VT_HAS_COLLISION = 8,
    VT_COLLISION_BORDER = 10,
    VT_PARALLAXSIZE = 12,
    VT_TILESIZE = 14,
    VT_SCROLLRATE = 16,
    VT_TILES = 18
  };
  bool has_parallax() const {
    return GetField<uint8_t>(VT_HAS_PARALLAX, 0) != 0;
  }
  bool has_scroll() const {
    return GetField<uint8_t>(VT_HAS_SCROLL, 0) != 0;
  }
  bool has_collision() const {
    return GetField<uint8_t>(VT_HAS_COLLISION, 0) != 0;
  }
  uint32_t collision_border() const {
    return GetField<uint32_t>(VT_COLLISION_BORDER, 0);
  }
  const flat::math::Vec2Fu *parallaxSize() const {
    return GetStruct<const flat::math::Vec2Fu *>(VT_PARALLAXSIZE);
  }
  const flat::math::Vec2Fu *tileSize() const {
    return GetStruct<const flat::math::Vec2Fu *>(VT_TILESIZE);
  }
  const flat::math::Vec2Ff *scrollrate() const {
    return GetStruct<const flat::math::Vec2Ff *>(VT_SCROLLRATE);
  }
  const flatbuffers::Vector<const flat::resources::TileRefF *> *tiles() const {
    return GetPointer<const flatbuffers::Vector<const flat::resources::TileRefF *> *>(VT_TILES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_HAS_PARALLAX) &&
           VerifyField<uint8_t>(verifier, VT_HAS_SCROLL) &&
           VerifyField<uint8_t>(verifier, VT_HAS_COLLISION) &&
           VerifyField<uint32_t>(verifier, VT_COLLISION_BORDER) &&
           VerifyField<flat::math::Vec2Fu>(verifier, VT_PARALLAXSIZE) &&
           VerifyField<flat::math::Vec2Fu>(verifier, VT_TILESIZE) &&
           VerifyField<flat::math::Vec2Ff>(verifier, VT_SCROLLRATE) &&
           VerifyOffset(verifier, VT_TILES) &&
           verifier.VerifyVector(tiles()) &&
           verifier.EndTable();
  }
};

struct TileLayerFBuilder {
  typedef TileLayerF Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_has_parallax(bool has_parallax) {
    fbb_.AddElement<uint8_t>(TileLayerF::VT_HAS_PARALLAX, static_cast<uint8_t>(has_parallax), 0);
  }
  void add_has_scroll(bool has_scroll) {
    fbb_.AddElement<uint8_t>(TileLayerF::VT_HAS_SCROLL, static_cast<uint8_t>(has_scroll), 0);
  }
  void add_has_collision(bool has_collision) {
    fbb_.AddElement<uint8_t>(TileLayerF::VT_HAS_COLLISION, static_cast<uint8_t>(has_collision), 0);
  }
  void add_collision_border(uint32_t collision_border) {
    fbb_.AddElement<uint32_t>(TileLayerF::VT_COLLISION_BORDER, collision_border, 0);
  }
  void add_parallaxSize(const flat::math::Vec2Fu *parallaxSize) {
    fbb_.AddStruct(TileLayerF::VT_PARALLAXSIZE, parallaxSize);
  }
  void add_tileSize(const flat::math::Vec2Fu *tileSize) {
    fbb_.AddStruct(TileLayerF::VT_TILESIZE, tileSize);
  }
  void add_scrollrate(const flat::math::Vec2Ff *scrollrate) {
    fbb_.AddStruct(TileLayerF::VT_SCROLLRATE, scrollrate);
  }
  void add_tiles(flatbuffers::Offset<flatbuffers::Vector<const flat::resources::TileRefF *>> tiles) {
    fbb_.AddOffset(TileLayerF::VT_TILES, tiles);
  }
  explicit TileLayerFBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TileLayerFBuilder &operator=(const TileLayerFBuilder &);
  flatbuffers::Offset<TileLayerF> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TileLayerF>(end);
    return o;
  }
};

inline flatbuffers::Offset<TileLayerF> CreateTileLayerF(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool has_parallax = false,
    bool has_scroll = false,
    bool has_collision = false,
    uint32_t collision_border = 0,
    const flat::math::Vec2Fu *parallaxSize = 0,
    const flat::math::Vec2Fu *tileSize = 0,
    const flat::math::Vec2Ff *scrollrate = 0,
    flatbuffers::Offset<flatbuffers::Vector<const flat::resources::TileRefF *>> tiles = 0) {
  TileLayerFBuilder builder_(_fbb);
  builder_.add_tiles(tiles);
  builder_.add_scrollrate(scrollrate);
  builder_.add_tileSize(tileSize);
  builder_.add_parallaxSize(parallaxSize);
  builder_.add_collision_border(collision_border);
  builder_.add_has_collision(has_collision);
  builder_.add_has_scroll(has_scroll);
  builder_.add_has_parallax(has_parallax);
  return builder_.Finish();
}

inline flatbuffers::Offset<TileLayerF> CreateTileLayerFDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool has_parallax = false,
    bool has_scroll = false,
    bool has_collision = false,
    uint32_t collision_border = 0,
    const flat::math::Vec2Fu *parallaxSize = 0,
    const flat::math::Vec2Fu *tileSize = 0,
    const flat::math::Vec2Ff *scrollrate = 0,
    const std::vector<flat::resources::TileRefF> *tiles = nullptr) {
  auto tiles__ = tiles ? _fbb.CreateVectorOfStructs<flat::resources::TileRefF>(*tiles) : 0;
  return flat::resources::CreateTileLayerF(
      _fbb,
      has_parallax,
      has_scroll,
      has_collision,
      collision_border,
      parallaxSize,
      tileSize,
      scrollrate,
      tiles__);
}

struct LevelLayerF FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LevelLayerFBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_LAYER_TYPE = 6,
    VT_LAYER = 8,
    VT_PROPERTIES = 10
  };
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  flat::resources::AnyLayerF layer_type() const {
    return static_cast<flat::resources::AnyLayerF>(GetField<uint8_t>(VT_LAYER_TYPE, 0));
  }
  const void *layer() const {
    return GetPointer<const void *>(VT_LAYER);
  }
  template<typename T> const T *layer_as() const;
  const flat::resources::TileLayerF *layer_as_TileLayerF() const {
    return layer_type() == flat::resources::AnyLayerF_TileLayerF ? static_cast<const flat::resources::TileLayerF *>(layer()) : nullptr;
  }
  const flat::resources::ObjectLayerF *layer_as_ObjectLayerF() const {
    return layer_type() == flat::resources::AnyLayerF_ObjectLayerF ? static_cast<const flat::resources::ObjectLayerF *>(layer()) : nullptr;
  }
  const flatbuffers::Vector<flatbuffers::Offset<flat::resources::PropertyF>> *properties() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flat::resources::PropertyF>> *>(VT_PROPERTIES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID) &&
           VerifyField<uint8_t>(verifier, VT_LAYER_TYPE) &&
           VerifyOffset(verifier, VT_LAYER) &&
           VerifyAnyLayerF(verifier, layer(), layer_type()) &&
           VerifyOffset(verifier, VT_PROPERTIES) &&
           verifier.VerifyVector(properties()) &&
           verifier.VerifyVectorOfTables(properties()) &&
           verifier.EndTable();
  }
};

template<> inline const flat::resources::TileLayerF *LevelLayerF::layer_as<flat::resources::TileLayerF>() const {
  return layer_as_TileLayerF();
}

template<> inline const flat::resources::ObjectLayerF *LevelLayerF::layer_as<flat::resources::ObjectLayerF>() const {
  return layer_as_ObjectLayerF();
}

struct LevelLayerFBuilder {
  typedef LevelLayerF Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(LevelLayerF::VT_ID, id, 0);
  }
  void add_layer_type(flat::resources::AnyLayerF layer_type) {
    fbb_.AddElement<uint8_t>(LevelLayerF::VT_LAYER_TYPE, static_cast<uint8_t>(layer_type), 0);
  }
  void add_layer(flatbuffers::Offset<void> layer) {
    fbb_.AddOffset(LevelLayerF::VT_LAYER, layer);
  }
  void add_properties(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::resources::PropertyF>>> properties) {
    fbb_.AddOffset(LevelLayerF::VT_PROPERTIES, properties);
  }
  explicit LevelLayerFBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LevelLayerFBuilder &operator=(const LevelLayerFBuilder &);
  flatbuffers::Offset<LevelLayerF> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LevelLayerF>(end);
    return o;
  }
};

inline flatbuffers::Offset<LevelLayerF> CreateLevelLayerF(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    flat::resources::AnyLayerF layer_type = flat::resources::AnyLayerF_NONE,
    flatbuffers::Offset<void> layer = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::resources::PropertyF>>> properties = 0) {
  LevelLayerFBuilder builder_(_fbb);
  builder_.add_properties(properties);
  builder_.add_layer(layer);
  builder_.add_id(id);
  builder_.add_layer_type(layer_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<LevelLayerF> CreateLevelLayerFDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    flat::resources::AnyLayerF layer_type = flat::resources::AnyLayerF_NONE,
    flatbuffers::Offset<void> layer = 0,
    const std::vector<flatbuffers::Offset<flat::resources::PropertyF>> *properties = nullptr) {
  auto properties__ = properties ? _fbb.CreateVector<flatbuffers::Offset<flat::resources::PropertyF>>(*properties) : 0;
  return flat::resources::CreateLevelLayerF(
      _fbb,
      id,
      layer_type,
      layer,
      properties__);
}

struct LevelTilesetDepF FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LevelTilesetDepFBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GID = 4,
    VT_TILESETNAME = 6
  };
  uint32_t gid() const {
    return GetField<uint32_t>(VT_GID, 0);
  }
  const flatbuffers::String *tilesetName() const {
    return GetPointer<const flatbuffers::String *>(VT_TILESETNAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_GID) &&
           VerifyOffset(verifier, VT_TILESETNAME) &&
           verifier.VerifyString(tilesetName()) &&
           verifier.EndTable();
  }
};

struct LevelTilesetDepFBuilder {
  typedef LevelTilesetDepF Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_gid(uint32_t gid) {
    fbb_.AddElement<uint32_t>(LevelTilesetDepF::VT_GID, gid, 0);
  }
  void add_tilesetName(flatbuffers::Offset<flatbuffers::String> tilesetName) {
    fbb_.AddOffset(LevelTilesetDepF::VT_TILESETNAME, tilesetName);
  }
  explicit LevelTilesetDepFBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LevelTilesetDepFBuilder &operator=(const LevelTilesetDepFBuilder &);
  flatbuffers::Offset<LevelTilesetDepF> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LevelTilesetDepF>(end);
    return o;
  }
};

inline flatbuffers::Offset<LevelTilesetDepF> CreateLevelTilesetDepF(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t gid = 0,
    flatbuffers::Offset<flatbuffers::String> tilesetName = 0) {
  LevelTilesetDepFBuilder builder_(_fbb);
  builder_.add_tilesetName(tilesetName);
  builder_.add_gid(gid);
  return builder_.Finish();
}

inline flatbuffers::Offset<LevelTilesetDepF> CreateLevelTilesetDepFDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t gid = 0,
    const char *tilesetName = nullptr) {
  auto tilesetName__ = tilesetName ? _fbb.CreateString(tilesetName) : 0;
  return flat::resources::CreateLevelTilesetDepF(
      _fbb,
      gid,
      tilesetName__);
}

struct LevelAssetF FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LevelAssetFBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_BGCOLOR = 6,
    VT_LVLSIZE = 8,
    VT_LAYERS = 10,
    VT_TILESETDEPS = 12,
    VT_BORDERS = 14
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  uint32_t bgColor() const {
    return GetField<uint32_t>(VT_BGCOLOR, 0);
  }
  const flat::math::Vec2Fu *lvlSize() const {
    return GetStruct<const flat::math::Vec2Fu *>(VT_LVLSIZE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flat::resources::LevelLayerF>> *layers() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flat::resources::LevelLayerF>> *>(VT_LAYERS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flat::resources::LevelTilesetDepF>> *tilesetDeps() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flat::resources::LevelTilesetDepF>> *>(VT_TILESETDEPS);
  }
  uint32_t borders() const {
    return GetField<uint32_t>(VT_BORDERS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint32_t>(verifier, VT_BGCOLOR) &&
           VerifyFieldRequired<flat::math::Vec2Fu>(verifier, VT_LVLSIZE) &&
           VerifyOffset(verifier, VT_LAYERS) &&
           verifier.VerifyVector(layers()) &&
           verifier.VerifyVectorOfTables(layers()) &&
           VerifyOffset(verifier, VT_TILESETDEPS) &&
           verifier.VerifyVector(tilesetDeps()) &&
           verifier.VerifyVectorOfTables(tilesetDeps()) &&
           VerifyField<uint32_t>(verifier, VT_BORDERS) &&
           verifier.EndTable();
  }
};

struct LevelAssetFBuilder {
  typedef LevelAssetF Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(LevelAssetF::VT_NAME, name);
  }
  void add_bgColor(uint32_t bgColor) {
    fbb_.AddElement<uint32_t>(LevelAssetF::VT_BGCOLOR, bgColor, 0);
  }
  void add_lvlSize(const flat::math::Vec2Fu *lvlSize) {
    fbb_.AddStruct(LevelAssetF::VT_LVLSIZE, lvlSize);
  }
  void add_layers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::resources::LevelLayerF>>> layers) {
    fbb_.AddOffset(LevelAssetF::VT_LAYERS, layers);
  }
  void add_tilesetDeps(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::resources::LevelTilesetDepF>>> tilesetDeps) {
    fbb_.AddOffset(LevelAssetF::VT_TILESETDEPS, tilesetDeps);
  }
  void add_borders(uint32_t borders) {
    fbb_.AddElement<uint32_t>(LevelAssetF::VT_BORDERS, borders, 0);
  }
  explicit LevelAssetFBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LevelAssetFBuilder &operator=(const LevelAssetFBuilder &);
  flatbuffers::Offset<LevelAssetF> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LevelAssetF>(end);
    fbb_.Required(o, LevelAssetF::VT_NAME);
    fbb_.Required(o, LevelAssetF::VT_LVLSIZE);
    return o;
  }
};

inline flatbuffers::Offset<LevelAssetF> CreateLevelAssetF(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    uint32_t bgColor = 0,
    const flat::math::Vec2Fu *lvlSize = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::resources::LevelLayerF>>> layers = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::resources::LevelTilesetDepF>>> tilesetDeps = 0,
    uint32_t borders = 0) {
  LevelAssetFBuilder builder_(_fbb);
  builder_.add_borders(borders);
  builder_.add_tilesetDeps(tilesetDeps);
  builder_.add_layers(layers);
  builder_.add_lvlSize(lvlSize);
  builder_.add_bgColor(bgColor);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<LevelAssetF> CreateLevelAssetFDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    uint32_t bgColor = 0,
    const flat::math::Vec2Fu *lvlSize = 0,
    const std::vector<flatbuffers::Offset<flat::resources::LevelLayerF>> *layers = nullptr,
    const std::vector<flatbuffers::Offset<flat::resources::LevelTilesetDepF>> *tilesetDeps = nullptr,
    uint32_t borders = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto layers__ = layers ? _fbb.CreateVector<flatbuffers::Offset<flat::resources::LevelLayerF>>(*layers) : 0;
  auto tilesetDeps__ = tilesetDeps ? _fbb.CreateVector<flatbuffers::Offset<flat::resources::LevelTilesetDepF>>(*tilesetDeps) : 0;
  return flat::resources::CreateLevelAssetF(
      _fbb,
      name__,
      bgColor,
      lvlSize,
      layers__,
      tilesetDeps__,
      borders);
}

struct TilesetLogicF FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TilesetLogicFBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LOGIC = 4,
    VT_LOGIC_ARG = 6
  };
  const flatbuffers::String *logic() const {
    return GetPointer<const flatbuffers::String *>(VT_LOGIC);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *logic_arg() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_LOGIC_ARG);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LOGIC) &&
           verifier.VerifyString(logic()) &&
           VerifyOffset(verifier, VT_LOGIC_ARG) &&
           verifier.VerifyVector(logic_arg()) &&
           verifier.VerifyVectorOfStrings(logic_arg()) &&
           verifier.EndTable();
  }
};

struct TilesetLogicFBuilder {
  typedef TilesetLogicF Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_logic(flatbuffers::Offset<flatbuffers::String> logic) {
    fbb_.AddOffset(TilesetLogicF::VT_LOGIC, logic);
  }
  void add_logic_arg(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> logic_arg) {
    fbb_.AddOffset(TilesetLogicF::VT_LOGIC_ARG, logic_arg);
  }
  explicit TilesetLogicFBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TilesetLogicFBuilder &operator=(const TilesetLogicFBuilder &);
  flatbuffers::Offset<TilesetLogicF> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TilesetLogicF>(end);
    fbb_.Required(o, TilesetLogicF::VT_LOGIC);
    return o;
  }
};

inline flatbuffers::Offset<TilesetLogicF> CreateTilesetLogicF(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> logic = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> logic_arg = 0) {
  TilesetLogicFBuilder builder_(_fbb);
  builder_.add_logic_arg(logic_arg);
  builder_.add_logic(logic);
  return builder_.Finish();
}

inline flatbuffers::Offset<TilesetLogicF> CreateTilesetLogicFDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *logic = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *logic_arg = nullptr) {
  auto logic__ = logic ? _fbb.CreateString(logic) : 0;
  auto logic_arg__ = logic_arg ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*logic_arg) : 0;
  return flat::resources::CreateTilesetLogicF(
      _fbb,
      logic__,
      logic_arg__);
}

struct TilesetAssetF FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TilesetAssetFBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_TILESIZE = 6,
    VT_TILEDATA = 8,
    VT_TILESETS = 10,
    VT_MATERIALS = 12,
    VT_LOGICS = 14,
    VT_IMAGE = 16
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flat::math::Vec2Fu *tileSize() const {
    return GetStruct<const flat::math::Vec2Fu *>(VT_TILESIZE);
  }
  const flatbuffers::Vector<const flat::resources::TileDataF *> *tileData() const {
    return GetPointer<const flatbuffers::Vector<const flat::resources::TileDataF *> *>(VT_TILEDATA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *tilesets() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_TILESETS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *materials() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_MATERIALS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flat::resources::TilesetLogicF>> *logics() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flat::resources::TilesetLogicF>> *>(VT_LOGICS);
  }
  const flatbuffers::Vector<int8_t> *image() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_IMAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyFieldRequired<flat::math::Vec2Fu>(verifier, VT_TILESIZE) &&
           VerifyOffset(verifier, VT_TILEDATA) &&
           verifier.VerifyVector(tileData()) &&
           VerifyOffset(verifier, VT_TILESETS) &&
           verifier.VerifyVector(tilesets()) &&
           verifier.VerifyVectorOfStrings(tilesets()) &&
           VerifyOffset(verifier, VT_MATERIALS) &&
           verifier.VerifyVector(materials()) &&
           verifier.VerifyVectorOfStrings(materials()) &&
           VerifyOffset(verifier, VT_LOGICS) &&
           verifier.VerifyVector(logics()) &&
           verifier.VerifyVectorOfTables(logics()) &&
           VerifyOffsetRequired(verifier, VT_IMAGE) &&
           verifier.VerifyVector(image()) &&
           verifier.EndTable();
  }
};

struct TilesetAssetFBuilder {
  typedef TilesetAssetF Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(TilesetAssetF::VT_NAME, name);
  }
  void add_tileSize(const flat::math::Vec2Fu *tileSize) {
    fbb_.AddStruct(TilesetAssetF::VT_TILESIZE, tileSize);
  }
  void add_tileData(flatbuffers::Offset<flatbuffers::Vector<const flat::resources::TileDataF *>> tileData) {
    fbb_.AddOffset(TilesetAssetF::VT_TILEDATA, tileData);
  }
  void add_tilesets(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> tilesets) {
    fbb_.AddOffset(TilesetAssetF::VT_TILESETS, tilesets);
  }
  void add_materials(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> materials) {
    fbb_.AddOffset(TilesetAssetF::VT_MATERIALS, materials);
  }
  void add_logics(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::resources::TilesetLogicF>>> logics) {
    fbb_.AddOffset(TilesetAssetF::VT_LOGICS, logics);
  }
  void add_image(flatbuffers::Offset<flatbuffers::Vector<int8_t>> image) {
    fbb_.AddOffset(TilesetAssetF::VT_IMAGE, image);
  }
  explicit TilesetAssetFBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TilesetAssetFBuilder &operator=(const TilesetAssetFBuilder &);
  flatbuffers::Offset<TilesetAssetF> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TilesetAssetF>(end);
    fbb_.Required(o, TilesetAssetF::VT_NAME);
    fbb_.Required(o, TilesetAssetF::VT_TILESIZE);
    fbb_.Required(o, TilesetAssetF::VT_IMAGE);
    return o;
  }
};

inline flatbuffers::Offset<TilesetAssetF> CreateTilesetAssetF(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    const flat::math::Vec2Fu *tileSize = 0,
    flatbuffers::Offset<flatbuffers::Vector<const flat::resources::TileDataF *>> tileData = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> tilesets = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> materials = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::resources::TilesetLogicF>>> logics = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> image = 0) {
  TilesetAssetFBuilder builder_(_fbb);
  builder_.add_image(image);
  builder_.add_logics(logics);
  builder_.add_materials(materials);
  builder_.add_tilesets(tilesets);
  builder_.add_tileData(tileData);
  builder_.add_tileSize(tileSize);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<TilesetAssetF> CreateTilesetAssetFDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const flat::math::Vec2Fu *tileSize = 0,
    const std::vector<flat::resources::TileDataF> *tileData = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *tilesets = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *materials = nullptr,
    const std::vector<flatbuffers::Offset<flat::resources::TilesetLogicF>> *logics = nullptr,
    const std::vector<int8_t> *image = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto tileData__ = tileData ? _fbb.CreateVectorOfStructs<flat::resources::TileDataF>(*tileData) : 0;
  auto tilesets__ = tilesets ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*tilesets) : 0;
  auto materials__ = materials ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*materials) : 0;
  auto logics__ = logics ? _fbb.CreateVector<flatbuffers::Offset<flat::resources::TilesetLogicF>>(*logics) : 0;
  auto image__ = image ? _fbb.CreateVector<int8_t>(*image) : 0;
  return flat::resources::CreateTilesetAssetF(
      _fbb,
      name__,
      tileSize,
      tileData__,
      tilesets__,
      materials__,
      logics__,
      image__);
}

struct AnimationAssetF FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AnimationAssetFBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_AREA = 6,
    VT_ORIGIN = 8,
    VT_FRAMERATEMS = 10,
    VT_LOOP = 12,
    VT_HAS_CHAIN = 14,
    VT_CHAIN_SPR_NAME = 16,
    VT_CHAIN_ANIM_NAME = 18,
    VT_CHAIN_FRAME = 20
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flat::math::RectFi *area() const {
    return GetStruct<const flat::math::RectFi *>(VT_AREA);
  }
  const flat::math::Vec2Fi *origin() const {
    return GetStruct<const flat::math::Vec2Fi *>(VT_ORIGIN);
  }
  const flatbuffers::Vector<uint32_t> *framerateMS() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_FRAMERATEMS);
  }
  uint32_t loop() const {
    return GetField<uint32_t>(VT_LOOP, 0);
  }
  bool has_chain() const {
    return GetField<uint8_t>(VT_HAS_CHAIN, 0) != 0;
  }
  const flatbuffers::String *chain_spr_name() const {
    return GetPointer<const flatbuffers::String *>(VT_CHAIN_SPR_NAME);
  }
  const flatbuffers::String *chain_anim_name() const {
    return GetPointer<const flatbuffers::String *>(VT_CHAIN_ANIM_NAME);
  }
  uint32_t chain_frame() const {
    return GetField<uint32_t>(VT_CHAIN_FRAME, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyFieldRequired<flat::math::RectFi>(verifier, VT_AREA) &&
           VerifyFieldRequired<flat::math::Vec2Fi>(verifier, VT_ORIGIN) &&
           VerifyOffsetRequired(verifier, VT_FRAMERATEMS) &&
           verifier.VerifyVector(framerateMS()) &&
           VerifyField<uint32_t>(verifier, VT_LOOP) &&
           VerifyField<uint8_t>(verifier, VT_HAS_CHAIN) &&
           VerifyOffset(verifier, VT_CHAIN_SPR_NAME) &&
           verifier.VerifyString(chain_spr_name()) &&
           VerifyOffset(verifier, VT_CHAIN_ANIM_NAME) &&
           verifier.VerifyString(chain_anim_name()) &&
           VerifyField<uint32_t>(verifier, VT_CHAIN_FRAME) &&
           verifier.EndTable();
  }
};

struct AnimationAssetFBuilder {
  typedef AnimationAssetF Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(AnimationAssetF::VT_NAME, name);
  }
  void add_area(const flat::math::RectFi *area) {
    fbb_.AddStruct(AnimationAssetF::VT_AREA, area);
  }
  void add_origin(const flat::math::Vec2Fi *origin) {
    fbb_.AddStruct(AnimationAssetF::VT_ORIGIN, origin);
  }
  void add_framerateMS(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> framerateMS) {
    fbb_.AddOffset(AnimationAssetF::VT_FRAMERATEMS, framerateMS);
  }
  void add_loop(uint32_t loop) {
    fbb_.AddElement<uint32_t>(AnimationAssetF::VT_LOOP, loop, 0);
  }
  void add_has_chain(bool has_chain) {
    fbb_.AddElement<uint8_t>(AnimationAssetF::VT_HAS_CHAIN, static_cast<uint8_t>(has_chain), 0);
  }
  void add_chain_spr_name(flatbuffers::Offset<flatbuffers::String> chain_spr_name) {
    fbb_.AddOffset(AnimationAssetF::VT_CHAIN_SPR_NAME, chain_spr_name);
  }
  void add_chain_anim_name(flatbuffers::Offset<flatbuffers::String> chain_anim_name) {
    fbb_.AddOffset(AnimationAssetF::VT_CHAIN_ANIM_NAME, chain_anim_name);
  }
  void add_chain_frame(uint32_t chain_frame) {
    fbb_.AddElement<uint32_t>(AnimationAssetF::VT_CHAIN_FRAME, chain_frame, 0);
  }
  explicit AnimationAssetFBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AnimationAssetFBuilder &operator=(const AnimationAssetFBuilder &);
  flatbuffers::Offset<AnimationAssetF> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AnimationAssetF>(end);
    fbb_.Required(o, AnimationAssetF::VT_NAME);
    fbb_.Required(o, AnimationAssetF::VT_AREA);
    fbb_.Required(o, AnimationAssetF::VT_ORIGIN);
    fbb_.Required(o, AnimationAssetF::VT_FRAMERATEMS);
    return o;
  }
};

inline flatbuffers::Offset<AnimationAssetF> CreateAnimationAssetF(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    const flat::math::RectFi *area = 0,
    const flat::math::Vec2Fi *origin = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> framerateMS = 0,
    uint32_t loop = 0,
    bool has_chain = false,
    flatbuffers::Offset<flatbuffers::String> chain_spr_name = 0,
    flatbuffers::Offset<flatbuffers::String> chain_anim_name = 0,
    uint32_t chain_frame = 0) {
  AnimationAssetFBuilder builder_(_fbb);
  builder_.add_chain_frame(chain_frame);
  builder_.add_chain_anim_name(chain_anim_name);
  builder_.add_chain_spr_name(chain_spr_name);
  builder_.add_loop(loop);
  builder_.add_framerateMS(framerateMS);
  builder_.add_origin(origin);
  builder_.add_area(area);
  builder_.add_name(name);
  builder_.add_has_chain(has_chain);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnimationAssetF> CreateAnimationAssetFDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const flat::math::RectFi *area = 0,
    const flat::math::Vec2Fi *origin = 0,
    const std::vector<uint32_t> *framerateMS = nullptr,
    uint32_t loop = 0,
    bool has_chain = false,
    const char *chain_spr_name = nullptr,
    const char *chain_anim_name = nullptr,
    uint32_t chain_frame = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto framerateMS__ = framerateMS ? _fbb.CreateVector<uint32_t>(*framerateMS) : 0;
  auto chain_spr_name__ = chain_spr_name ? _fbb.CreateString(chain_spr_name) : 0;
  auto chain_anim_name__ = chain_anim_name ? _fbb.CreateString(chain_anim_name) : 0;
  return flat::resources::CreateAnimationAssetF(
      _fbb,
      name__,
      area,
      origin,
      framerateMS__,
      loop,
      has_chain,
      chain_spr_name__,
      chain_anim_name__,
      chain_frame);
}

struct SpriteAssetF FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SpriteAssetFBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_ANIMATIONS = 6,
    VT_IMAGE = 8
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flat::resources::AnimationAssetF>> *animations() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flat::resources::AnimationAssetF>> *>(VT_ANIMATIONS);
  }
  const flatbuffers::Vector<int8_t> *image() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_IMAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_ANIMATIONS) &&
           verifier.VerifyVector(animations()) &&
           verifier.VerifyVectorOfTables(animations()) &&
           VerifyOffsetRequired(verifier, VT_IMAGE) &&
           verifier.VerifyVector(image()) &&
           verifier.EndTable();
  }
};

struct SpriteAssetFBuilder {
  typedef SpriteAssetF Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(SpriteAssetF::VT_NAME, name);
  }
  void add_animations(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::resources::AnimationAssetF>>> animations) {
    fbb_.AddOffset(SpriteAssetF::VT_ANIMATIONS, animations);
  }
  void add_image(flatbuffers::Offset<flatbuffers::Vector<int8_t>> image) {
    fbb_.AddOffset(SpriteAssetF::VT_IMAGE, image);
  }
  explicit SpriteAssetFBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SpriteAssetFBuilder &operator=(const SpriteAssetFBuilder &);
  flatbuffers::Offset<SpriteAssetF> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SpriteAssetF>(end);
    fbb_.Required(o, SpriteAssetF::VT_NAME);
    fbb_.Required(o, SpriteAssetF::VT_IMAGE);
    return o;
  }
};

inline flatbuffers::Offset<SpriteAssetF> CreateSpriteAssetF(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::resources::AnimationAssetF>>> animations = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> image = 0) {
  SpriteAssetFBuilder builder_(_fbb);
  builder_.add_image(image);
  builder_.add_animations(animations);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<SpriteAssetF> CreateSpriteAssetFDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<flatbuffers::Offset<flat::resources::AnimationAssetF>> *animations = nullptr,
    const std::vector<int8_t> *image = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto animations__ = animations ? _fbb.CreateVector<flatbuffers::Offset<flat::resources::AnimationAssetF>>(*animations) : 0;
  auto image__ = image ? _fbb.CreateVector<int8_t>(*image) : 0;
  return flat::resources::CreateSpriteAssetF(
      _fbb,
      name__,
      animations__,
      image__);
}

struct ResourcesF FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ResourcesFBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SPRITES = 4,
    VT_TILESETS = 6,
    VT_LEVELS = 8
  };
  const flatbuffers::Vector<flatbuffers::Offset<flat::resources::SpriteAssetF>> *sprites() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flat::resources::SpriteAssetF>> *>(VT_SPRITES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flat::resources::TilesetAssetF>> *tilesets() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flat::resources::TilesetAssetF>> *>(VT_TILESETS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flat::resources::LevelAssetF>> *levels() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flat::resources::LevelAssetF>> *>(VT_LEVELS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SPRITES) &&
           verifier.VerifyVector(sprites()) &&
           verifier.VerifyVectorOfTables(sprites()) &&
           VerifyOffset(verifier, VT_TILESETS) &&
           verifier.VerifyVector(tilesets()) &&
           verifier.VerifyVectorOfTables(tilesets()) &&
           VerifyOffset(verifier, VT_LEVELS) &&
           verifier.VerifyVector(levels()) &&
           verifier.VerifyVectorOfTables(levels()) &&
           verifier.EndTable();
  }
};

struct ResourcesFBuilder {
  typedef ResourcesF Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_sprites(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::resources::SpriteAssetF>>> sprites) {
    fbb_.AddOffset(ResourcesF::VT_SPRITES, sprites);
  }
  void add_tilesets(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::resources::TilesetAssetF>>> tilesets) {
    fbb_.AddOffset(ResourcesF::VT_TILESETS, tilesets);
  }
  void add_levels(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::resources::LevelAssetF>>> levels) {
    fbb_.AddOffset(ResourcesF::VT_LEVELS, levels);
  }
  explicit ResourcesFBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ResourcesFBuilder &operator=(const ResourcesFBuilder &);
  flatbuffers::Offset<ResourcesF> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ResourcesF>(end);
    return o;
  }
};

inline flatbuffers::Offset<ResourcesF> CreateResourcesF(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::resources::SpriteAssetF>>> sprites = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::resources::TilesetAssetF>>> tilesets = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::resources::LevelAssetF>>> levels = 0) {
  ResourcesFBuilder builder_(_fbb);
  builder_.add_levels(levels);
  builder_.add_tilesets(tilesets);
  builder_.add_sprites(sprites);
  return builder_.Finish();
}

inline flatbuffers::Offset<ResourcesF> CreateResourcesFDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<flat::resources::SpriteAssetF>> *sprites = nullptr,
    const std::vector<flatbuffers::Offset<flat::resources::TilesetAssetF>> *tilesets = nullptr,
    const std::vector<flatbuffers::Offset<flat::resources::LevelAssetF>> *levels = nullptr) {
  auto sprites__ = sprites ? _fbb.CreateVector<flatbuffers::Offset<flat::resources::SpriteAssetF>>(*sprites) : 0;
  auto tilesets__ = tilesets ? _fbb.CreateVector<flatbuffers::Offset<flat::resources::TilesetAssetF>>(*tilesets) : 0;
  auto levels__ = levels ? _fbb.CreateVector<flatbuffers::Offset<flat::resources::LevelAssetF>>(*levels) : 0;
  return flat::resources::CreateResourcesF(
      _fbb,
      sprites__,
      tilesets__,
      levels__);
}

inline bool VerifyAnyLayerF(flatbuffers::Verifier &verifier, const void *obj, AnyLayerF type) {
  switch (type) {
    case AnyLayerF_NONE: {
      return true;
    }
    case AnyLayerF_TileLayerF: {
      auto ptr = reinterpret_cast<const flat::resources::TileLayerF *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyLayerF_ObjectLayerF: {
      auto ptr = reinterpret_cast<const flat::resources::ObjectLayerF *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyAnyLayerFVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyAnyLayerF(
        verifier,  values->Get(i), types->GetEnum<AnyLayerF>(i))) {
      return false;
    }
  }
  return true;
}

inline const flat::resources::ResourcesF *GetResourcesF(const void *buf) {
  return flatbuffers::GetRoot<flat::resources::ResourcesF>(buf);
}

inline const flat::resources::ResourcesF *GetSizePrefixedResourcesF(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<flat::resources::ResourcesF>(buf);
}

inline const char *ResourcesFIdentifier() {
  return "PACK";
}

inline bool ResourcesFBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, ResourcesFIdentifier());
}

inline bool VerifyResourcesFBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<flat::resources::ResourcesF>(ResourcesFIdentifier());
}

inline bool VerifySizePrefixedResourcesFBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<flat::resources::ResourcesF>(ResourcesFIdentifier());
}

inline const char *ResourcesFExtension() {
  return "pack";
}

inline void FinishResourcesFBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<flat::resources::ResourcesF> root) {
  fbb.Finish(root, ResourcesFIdentifier());
}

inline void FinishSizePrefixedResourcesFBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<flat::resources::ResourcesF> root) {
  fbb.FinishSizePrefixed(root, ResourcesFIdentifier());
}

}  // namespace resources
}  // namespace flat

#endif  // FLATBUFFERS_GENERATED_RESOURCE_FLAT_RESOURCES_H_
