// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_RESOURCE_FLAT_RESOURCES_H_
#define FLATBUFFERS_GENERATED_RESOURCE_FLAT_RESOURCES_H_

#include "flatbuffers/flatbuffers.h"

#include "math-flat.hpp"

namespace flat {
namespace resources {

struct PropertyF;
struct PropertyFBuilder;

struct ObjectF;
struct ObjectFBuilder;

struct ObjectLayerF;
struct ObjectLayerFBuilder;

struct TileLayerF;
struct TileLayerFBuilder;

struct LevelLayerF;
struct LevelLayerFBuilder;

struct LevelTilesetDepF;
struct LevelTilesetDepFBuilder;

struct LevelAssetF;
struct LevelAssetFBuilder;

struct TileShapeF;

struct TileF;

struct TileDataF;

struct TilesetLogicF;
struct TilesetLogicFBuilder;

struct TilesetAssetF;
struct TilesetAssetFBuilder;

struct AnimationAssetF;
struct AnimationAssetFBuilder;

struct SpriteAssetF;
struct SpriteAssetFBuilder;

struct ResourcesF;
struct ResourcesFBuilder;

enum AnyLayerF : uint8_t {
  AnyLayerF_NONE = 0,
  AnyLayerF_TileLayerF = 1,
  AnyLayerF_ObjectLayerF = 2,
  AnyLayerF_MIN = AnyLayerF_NONE,
  AnyLayerF_MAX = AnyLayerF_ObjectLayerF
};

inline const AnyLayerF (&EnumValuesAnyLayerF())[3] {
  static const AnyLayerF values[] = {
    AnyLayerF_NONE,
    AnyLayerF_TileLayerF,
    AnyLayerF_ObjectLayerF
  };
  return values;
}

inline const char * const *EnumNamesAnyLayerF() {
  static const char * const names[4] = {
    "NONE",
    "TileLayerF",
    "ObjectLayerF",
    nullptr
  };
  return names;
}

inline const char *EnumNameAnyLayerF(AnyLayerF e) {
  if (flatbuffers::IsOutRange(e, AnyLayerF_NONE, AnyLayerF_ObjectLayerF)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAnyLayerF()[index];
}

template<typename T> struct AnyLayerFTraits {
  static const AnyLayerF enum_value = AnyLayerF_NONE;
};

template<> struct AnyLayerFTraits<flat::resources::TileLayerF> {
  static const AnyLayerF enum_value = AnyLayerF_TileLayerF;
};

template<> struct AnyLayerFTraits<flat::resources::ObjectLayerF> {
  static const AnyLayerF enum_value = AnyLayerF_ObjectLayerF;
};

bool VerifyAnyLayerF(flatbuffers::Verifier &verifier, const void *obj, AnyLayerF type);
bool VerifyAnyLayerFVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) TileShapeF FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t type_;
  uint8_t hflip_;
  uint8_t vflip_;
  int16_t padding0__;

 public:
  TileShapeF()
      : type_(0),
        hflip_(0),
        vflip_(0),
        padding0__(0) {
    (void)padding0__;
  }
  TileShapeF(uint32_t _type, bool _hflip, bool _vflip)
      : type_(flatbuffers::EndianScalar(_type)),
        hflip_(flatbuffers::EndianScalar(static_cast<uint8_t>(_hflip))),
        vflip_(flatbuffers::EndianScalar(static_cast<uint8_t>(_vflip))),
        padding0__(0) {
    (void)padding0__;
  }
  uint32_t type() const {
    return flatbuffers::EndianScalar(type_);
  }
  bool hflip() const {
    return flatbuffers::EndianScalar(hflip_) != 0;
  }
  bool vflip() const {
    return flatbuffers::EndianScalar(vflip_) != 0;
  }
};
FLATBUFFERS_STRUCT_END(TileShapeF, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) TileF FLATBUFFERS_FINAL_CLASS {
 private:
  uint16_t pos_;
  int16_t padding0__;
  flat::resources::TileShapeF shape_;
  uint8_t facing_;
  int8_t padding1__;
  uint16_t next_offset_;
  uint8_t has_next_tileset_;
  int8_t padding2__;  int16_t padding3__;
  uint32_t next_tileset_ndx_;

 public:
  TileF()
      : pos_(0),
        padding0__(0),
        shape_(),
        facing_(0),
        padding1__(0),
        next_offset_(0),
        has_next_tileset_(0),
        padding2__(0),
        padding3__(0),
        next_tileset_ndx_(0) {
    (void)padding0__;
    (void)padding1__;
    (void)padding2__;
    (void)padding3__;
  }
  TileF(uint16_t _pos, const flat::resources::TileShapeF &_shape, flat::math::CardinalF _facing, uint16_t _next_offset, bool _has_next_tileset, uint32_t _next_tileset_ndx)
      : pos_(flatbuffers::EndianScalar(_pos)),
        padding0__(0),
        shape_(_shape),
        facing_(flatbuffers::EndianScalar(static_cast<uint8_t>(_facing))),
        padding1__(0),
        next_offset_(flatbuffers::EndianScalar(_next_offset)),
        has_next_tileset_(flatbuffers::EndianScalar(static_cast<uint8_t>(_has_next_tileset))),
        padding2__(0),
        padding3__(0),
        next_tileset_ndx_(flatbuffers::EndianScalar(_next_tileset_ndx)) {
    (void)padding0__;
    (void)padding1__;
    (void)padding2__;
    (void)padding3__;
  }
  uint16_t pos() const {
    return flatbuffers::EndianScalar(pos_);
  }
  const flat::resources::TileShapeF &shape() const {
    return shape_;
  }
  flat::math::CardinalF facing() const {
    return static_cast<flat::math::CardinalF>(flatbuffers::EndianScalar(facing_));
  }
  uint16_t next_offset() const {
    return flatbuffers::EndianScalar(next_offset_);
  }
  bool has_next_tileset() const {
    return flatbuffers::EndianScalar(has_next_tileset_) != 0;
  }
  uint32_t next_tileset_ndx() const {
    return flatbuffers::EndianScalar(next_tileset_ndx_);
  }
};
FLATBUFFERS_STRUCT_END(TileF, 24);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) TileDataF FLATBUFFERS_FINAL_CLASS {
 private:
  flat::resources::TileF tile_;
  uint8_t has_prop_bits_;
  int8_t padding0__;  int16_t padding1__;
  uint32_t logic_ndx_;
  uint32_t logic_arg_ndx_;
  uint32_t material_ndx_;

 public:
  TileDataF()
      : tile_(),
        has_prop_bits_(0),
        padding0__(0),
        padding1__(0),
        logic_ndx_(0),
        logic_arg_ndx_(0),
        material_ndx_(0) {
    (void)padding0__;
    (void)padding1__;
  }
  TileDataF(const flat::resources::TileF &_tile, uint8_t _has_prop_bits, uint32_t _logic_ndx, uint32_t _logic_arg_ndx, uint32_t _material_ndx)
      : tile_(_tile),
        has_prop_bits_(flatbuffers::EndianScalar(_has_prop_bits)),
        padding0__(0),
        padding1__(0),
        logic_ndx_(flatbuffers::EndianScalar(_logic_ndx)),
        logic_arg_ndx_(flatbuffers::EndianScalar(_logic_arg_ndx)),
        material_ndx_(flatbuffers::EndianScalar(_material_ndx)) {
    (void)padding0__;
    (void)padding1__;
  }
  const flat::resources::TileF &tile() const {
    return tile_;
  }
  uint8_t has_prop_bits() const {
    return flatbuffers::EndianScalar(has_prop_bits_);
  }
  uint32_t logic_ndx() const {
    return flatbuffers::EndianScalar(logic_ndx_);
  }
  uint32_t logic_arg_ndx() const {
    return flatbuffers::EndianScalar(logic_arg_ndx_);
  }
  uint32_t material_ndx() const {
    return flatbuffers::EndianScalar(material_ndx_);
  }
};
FLATBUFFERS_STRUCT_END(TileDataF, 40);

struct PropertyF FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PropertyFBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_VALUE = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *value() const {
    return GetPointer<const flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           verifier.EndTable();
  }
};

struct PropertyFBuilder {
  typedef PropertyF Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(PropertyF::VT_NAME, name);
  }
  void add_value(flatbuffers::Offset<flatbuffers::String> value) {
    fbb_.AddOffset(PropertyF::VT_VALUE, value);
  }
  explicit PropertyFBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PropertyF> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PropertyF>(end);
    return o;
  }
};

inline flatbuffers::Offset<PropertyF> CreatePropertyF(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> value = 0) {
  PropertyFBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<PropertyF> CreatePropertyFDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *value = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto value__ = value ? _fbb.CreateString(value) : 0;
  return flat::resources::CreatePropertyF(
      _fbb,
      name__,
      value__);
}

struct ObjectF FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ObjectFBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_NAME = 6,
    VT_TYPE_HASH = 8,
    VT_POS = 10,
    VT_WIDTH = 12,
    VT_HEIGHT = 14,
    VT_PROPERTIES = 16,
    VT_POINTS = 18
  };
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  uint64_t type_hash() const {
    return GetField<uint64_t>(VT_TYPE_HASH, 0);
  }
  const flat::math::Vec2Fi *pos() const {
    return GetStruct<const flat::math::Vec2Fi *>(VT_POS);
  }
  uint32_t width() const {
    return GetField<uint32_t>(VT_WIDTH, 0);
  }
  uint32_t height() const {
    return GetField<uint32_t>(VT_HEIGHT, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flat::resources::PropertyF>> *properties() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flat::resources::PropertyF>> *>(VT_PROPERTIES);
  }
  const flatbuffers::Vector<const flat::math::Vec2Fi *> *points() const {
    return GetPointer<const flatbuffers::Vector<const flat::math::Vec2Fi *> *>(VT_POINTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint64_t>(verifier, VT_TYPE_HASH) &&
           VerifyFieldRequired<flat::math::Vec2Fi>(verifier, VT_POS) &&
           VerifyField<uint32_t>(verifier, VT_WIDTH) &&
           VerifyField<uint32_t>(verifier, VT_HEIGHT) &&
           VerifyOffset(verifier, VT_PROPERTIES) &&
           verifier.VerifyVector(properties()) &&
           verifier.VerifyVectorOfTables(properties()) &&
           VerifyOffset(verifier, VT_POINTS) &&
           verifier.VerifyVector(points()) &&
           verifier.EndTable();
  }
};

struct ObjectFBuilder {
  typedef ObjectF Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(ObjectF::VT_ID, id, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(ObjectF::VT_NAME, name);
  }
  void add_type_hash(uint64_t type_hash) {
    fbb_.AddElement<uint64_t>(ObjectF::VT_TYPE_HASH, type_hash, 0);
  }
  void add_pos(const flat::math::Vec2Fi *pos) {
    fbb_.AddStruct(ObjectF::VT_POS, pos);
  }
  void add_width(uint32_t width) {
    fbb_.AddElement<uint32_t>(ObjectF::VT_WIDTH, width, 0);
  }
  void add_height(uint32_t height) {
    fbb_.AddElement<uint32_t>(ObjectF::VT_HEIGHT, height, 0);
  }
  void add_properties(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::resources::PropertyF>>> properties) {
    fbb_.AddOffset(ObjectF::VT_PROPERTIES, properties);
  }
  void add_points(flatbuffers::Offset<flatbuffers::Vector<const flat::math::Vec2Fi *>> points) {
    fbb_.AddOffset(ObjectF::VT_POINTS, points);
  }
  explicit ObjectFBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ObjectF> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ObjectF>(end);
    fbb_.Required(o, ObjectF::VT_NAME);
    fbb_.Required(o, ObjectF::VT_POS);
    return o;
  }
};

inline flatbuffers::Offset<ObjectF> CreateObjectF(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    uint64_t type_hash = 0,
    const flat::math::Vec2Fi *pos = 0,
    uint32_t width = 0,
    uint32_t height = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::resources::PropertyF>>> properties = 0,
    flatbuffers::Offset<flatbuffers::Vector<const flat::math::Vec2Fi *>> points = 0) {
  ObjectFBuilder builder_(_fbb);
  builder_.add_type_hash(type_hash);
  builder_.add_points(points);
  builder_.add_properties(properties);
  builder_.add_height(height);
  builder_.add_width(width);
  builder_.add_pos(pos);
  builder_.add_name(name);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<ObjectF> CreateObjectFDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    const char *name = nullptr,
    uint64_t type_hash = 0,
    const flat::math::Vec2Fi *pos = 0,
    uint32_t width = 0,
    uint32_t height = 0,
    const std::vector<flatbuffers::Offset<flat::resources::PropertyF>> *properties = nullptr,
    const std::vector<flat::math::Vec2Fi> *points = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto properties__ = properties ? _fbb.CreateVector<flatbuffers::Offset<flat::resources::PropertyF>>(*properties) : 0;
  auto points__ = points ? _fbb.CreateVectorOfStructs<flat::math::Vec2Fi>(*points) : 0;
  return flat::resources::CreateObjectF(
      _fbb,
      id,
      name__,
      type_hash,
      pos,
      width,
      height,
      properties__,
      points__);
}

struct ObjectLayerF FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ObjectLayerFBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OBJECTS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<flat::resources::ObjectF>> *objects() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flat::resources::ObjectF>> *>(VT_OBJECTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_OBJECTS) &&
           verifier.VerifyVector(objects()) &&
           verifier.VerifyVectorOfTables(objects()) &&
           verifier.EndTable();
  }
};

struct ObjectLayerFBuilder {
  typedef ObjectLayerF Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objects(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::resources::ObjectF>>> objects) {
    fbb_.AddOffset(ObjectLayerF::VT_OBJECTS, objects);
  }
  explicit ObjectLayerFBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ObjectLayerF> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ObjectLayerF>(end);
    return o;
  }
};

inline flatbuffers::Offset<ObjectLayerF> CreateObjectLayerF(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::resources::ObjectF>>> objects = 0) {
  ObjectLayerFBuilder builder_(_fbb);
  builder_.add_objects(objects);
  return builder_.Finish();
}

inline flatbuffers::Offset<ObjectLayerF> CreateObjectLayerFDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<flat::resources::ObjectF>> *objects = nullptr) {
  auto objects__ = objects ? _fbb.CreateVector<flatbuffers::Offset<flat::resources::ObjectF>>(*objects) : 0;
  return flat::resources::CreateObjectLayerF(
      _fbb,
      objects__);
}

struct TileLayerF FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TileLayerFBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LAYER_ID = 4,
    VT_HAS_PARALLAX = 6,
    VT_HAS_SCROLL = 8,
    VT_HAS_COLLISION = 10,
    VT_COLLISION_BORDER = 12,
    VT_PARALLAX_SIZE = 14,
    VT_SCROLL_RATE = 16,
    VT_TILE_SIZE = 18,
    VT_HAS_TILE = 20,
    VT_POS = 22,
    VT_TEX_POS = 24,
    VT_TILESET_NDX = 26,
    VT_TILESETS = 28
  };
  uint32_t layer_id() const {
    return GetField<uint32_t>(VT_LAYER_ID, 0);
  }
  bool has_parallax() const {
    return GetField<uint8_t>(VT_HAS_PARALLAX, 0) != 0;
  }
  bool has_scroll() const {
    return GetField<uint8_t>(VT_HAS_SCROLL, 0) != 0;
  }
  bool has_collision() const {
    return GetField<uint8_t>(VT_HAS_COLLISION, 0) != 0;
  }
  uint32_t collision_border() const {
    return GetField<uint32_t>(VT_COLLISION_BORDER, 0);
  }
  const flat::math::Vec2Fu *parallax_size() const {
    return GetStruct<const flat::math::Vec2Fu *>(VT_PARALLAX_SIZE);
  }
  const flat::math::Vec2Ff *scroll_rate() const {
    return GetStruct<const flat::math::Vec2Ff *>(VT_SCROLL_RATE);
  }
  const flat::math::Vec2Fu *tile_size() const {
    return GetStruct<const flat::math::Vec2Fu *>(VT_TILE_SIZE);
  }
  const flatbuffers::Vector<uint8_t> *has_tile() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_HAS_TILE);
  }
  const flatbuffers::Vector<const flat::math::Vec2Fu *> *pos() const {
    return GetPointer<const flatbuffers::Vector<const flat::math::Vec2Fu *> *>(VT_POS);
  }
  const flatbuffers::Vector<const flat::math::Vec2Fu *> *tex_pos() const {
    return GetPointer<const flatbuffers::Vector<const flat::math::Vec2Fu *> *>(VT_TEX_POS);
  }
  const flatbuffers::Vector<uint8_t> *tileset_ndx() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_TILESET_NDX);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *tilesets() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_TILESETS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_LAYER_ID) &&
           VerifyField<uint8_t>(verifier, VT_HAS_PARALLAX) &&
           VerifyField<uint8_t>(verifier, VT_HAS_SCROLL) &&
           VerifyField<uint8_t>(verifier, VT_HAS_COLLISION) &&
           VerifyField<uint32_t>(verifier, VT_COLLISION_BORDER) &&
           VerifyField<flat::math::Vec2Fu>(verifier, VT_PARALLAX_SIZE) &&
           VerifyField<flat::math::Vec2Ff>(verifier, VT_SCROLL_RATE) &&
           VerifyField<flat::math::Vec2Fu>(verifier, VT_TILE_SIZE) &&
           VerifyOffset(verifier, VT_HAS_TILE) &&
           verifier.VerifyVector(has_tile()) &&
           VerifyOffset(verifier, VT_POS) &&
           verifier.VerifyVector(pos()) &&
           VerifyOffset(verifier, VT_TEX_POS) &&
           verifier.VerifyVector(tex_pos()) &&
           VerifyOffset(verifier, VT_TILESET_NDX) &&
           verifier.VerifyVector(tileset_ndx()) &&
           VerifyOffset(verifier, VT_TILESETS) &&
           verifier.VerifyVector(tilesets()) &&
           verifier.VerifyVectorOfStrings(tilesets()) &&
           verifier.EndTable();
  }
};

struct TileLayerFBuilder {
  typedef TileLayerF Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_layer_id(uint32_t layer_id) {
    fbb_.AddElement<uint32_t>(TileLayerF::VT_LAYER_ID, layer_id, 0);
  }
  void add_has_parallax(bool has_parallax) {
    fbb_.AddElement<uint8_t>(TileLayerF::VT_HAS_PARALLAX, static_cast<uint8_t>(has_parallax), 0);
  }
  void add_has_scroll(bool has_scroll) {
    fbb_.AddElement<uint8_t>(TileLayerF::VT_HAS_SCROLL, static_cast<uint8_t>(has_scroll), 0);
  }
  void add_has_collision(bool has_collision) {
    fbb_.AddElement<uint8_t>(TileLayerF::VT_HAS_COLLISION, static_cast<uint8_t>(has_collision), 0);
  }
  void add_collision_border(uint32_t collision_border) {
    fbb_.AddElement<uint32_t>(TileLayerF::VT_COLLISION_BORDER, collision_border, 0);
  }
  void add_parallax_size(const flat::math::Vec2Fu *parallax_size) {
    fbb_.AddStruct(TileLayerF::VT_PARALLAX_SIZE, parallax_size);
  }
  void add_scroll_rate(const flat::math::Vec2Ff *scroll_rate) {
    fbb_.AddStruct(TileLayerF::VT_SCROLL_RATE, scroll_rate);
  }
  void add_tile_size(const flat::math::Vec2Fu *tile_size) {
    fbb_.AddStruct(TileLayerF::VT_TILE_SIZE, tile_size);
  }
  void add_has_tile(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> has_tile) {
    fbb_.AddOffset(TileLayerF::VT_HAS_TILE, has_tile);
  }
  void add_pos(flatbuffers::Offset<flatbuffers::Vector<const flat::math::Vec2Fu *>> pos) {
    fbb_.AddOffset(TileLayerF::VT_POS, pos);
  }
  void add_tex_pos(flatbuffers::Offset<flatbuffers::Vector<const flat::math::Vec2Fu *>> tex_pos) {
    fbb_.AddOffset(TileLayerF::VT_TEX_POS, tex_pos);
  }
  void add_tileset_ndx(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> tileset_ndx) {
    fbb_.AddOffset(TileLayerF::VT_TILESET_NDX, tileset_ndx);
  }
  void add_tilesets(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> tilesets) {
    fbb_.AddOffset(TileLayerF::VT_TILESETS, tilesets);
  }
  explicit TileLayerFBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TileLayerF> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TileLayerF>(end);
    return o;
  }
};

inline flatbuffers::Offset<TileLayerF> CreateTileLayerF(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t layer_id = 0,
    bool has_parallax = false,
    bool has_scroll = false,
    bool has_collision = false,
    uint32_t collision_border = 0,
    const flat::math::Vec2Fu *parallax_size = 0,
    const flat::math::Vec2Ff *scroll_rate = 0,
    const flat::math::Vec2Fu *tile_size = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> has_tile = 0,
    flatbuffers::Offset<flatbuffers::Vector<const flat::math::Vec2Fu *>> pos = 0,
    flatbuffers::Offset<flatbuffers::Vector<const flat::math::Vec2Fu *>> tex_pos = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> tileset_ndx = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> tilesets = 0) {
  TileLayerFBuilder builder_(_fbb);
  builder_.add_tilesets(tilesets);
  builder_.add_tileset_ndx(tileset_ndx);
  builder_.add_tex_pos(tex_pos);
  builder_.add_pos(pos);
  builder_.add_has_tile(has_tile);
  builder_.add_tile_size(tile_size);
  builder_.add_scroll_rate(scroll_rate);
  builder_.add_parallax_size(parallax_size);
  builder_.add_collision_border(collision_border);
  builder_.add_layer_id(layer_id);
  builder_.add_has_collision(has_collision);
  builder_.add_has_scroll(has_scroll);
  builder_.add_has_parallax(has_parallax);
  return builder_.Finish();
}

inline flatbuffers::Offset<TileLayerF> CreateTileLayerFDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t layer_id = 0,
    bool has_parallax = false,
    bool has_scroll = false,
    bool has_collision = false,
    uint32_t collision_border = 0,
    const flat::math::Vec2Fu *parallax_size = 0,
    const flat::math::Vec2Ff *scroll_rate = 0,
    const flat::math::Vec2Fu *tile_size = 0,
    const std::vector<uint8_t> *has_tile = nullptr,
    const std::vector<flat::math::Vec2Fu> *pos = nullptr,
    const std::vector<flat::math::Vec2Fu> *tex_pos = nullptr,
    const std::vector<uint8_t> *tileset_ndx = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *tilesets = nullptr) {
  auto has_tile__ = has_tile ? _fbb.CreateVector<uint8_t>(*has_tile) : 0;
  auto pos__ = pos ? _fbb.CreateVectorOfStructs<flat::math::Vec2Fu>(*pos) : 0;
  auto tex_pos__ = tex_pos ? _fbb.CreateVectorOfStructs<flat::math::Vec2Fu>(*tex_pos) : 0;
  auto tileset_ndx__ = tileset_ndx ? _fbb.CreateVector<uint8_t>(*tileset_ndx) : 0;
  auto tilesets__ = tilesets ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*tilesets) : 0;
  return flat::resources::CreateTileLayerF(
      _fbb,
      layer_id,
      has_parallax,
      has_scroll,
      has_collision,
      collision_border,
      parallax_size,
      scroll_rate,
      tile_size,
      has_tile__,
      pos__,
      tex_pos__,
      tileset_ndx__,
      tilesets__);
}

struct LevelLayerF FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LevelLayerFBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_LAYER_TYPE = 6,
    VT_LAYER = 8,
    VT_PROPERTIES = 10
  };
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  flat::resources::AnyLayerF layer_type() const {
    return static_cast<flat::resources::AnyLayerF>(GetField<uint8_t>(VT_LAYER_TYPE, 0));
  }
  const void *layer() const {
    return GetPointer<const void *>(VT_LAYER);
  }
  template<typename T> const T *layer_as() const;
  const flat::resources::TileLayerF *layer_as_TileLayerF() const {
    return layer_type() == flat::resources::AnyLayerF_TileLayerF ? static_cast<const flat::resources::TileLayerF *>(layer()) : nullptr;
  }
  const flat::resources::ObjectLayerF *layer_as_ObjectLayerF() const {
    return layer_type() == flat::resources::AnyLayerF_ObjectLayerF ? static_cast<const flat::resources::ObjectLayerF *>(layer()) : nullptr;
  }
  const flatbuffers::Vector<flatbuffers::Offset<flat::resources::PropertyF>> *properties() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flat::resources::PropertyF>> *>(VT_PROPERTIES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID) &&
           VerifyField<uint8_t>(verifier, VT_LAYER_TYPE) &&
           VerifyOffset(verifier, VT_LAYER) &&
           VerifyAnyLayerF(verifier, layer(), layer_type()) &&
           VerifyOffset(verifier, VT_PROPERTIES) &&
           verifier.VerifyVector(properties()) &&
           verifier.VerifyVectorOfTables(properties()) &&
           verifier.EndTable();
  }
};

template<> inline const flat::resources::TileLayerF *LevelLayerF::layer_as<flat::resources::TileLayerF>() const {
  return layer_as_TileLayerF();
}

template<> inline const flat::resources::ObjectLayerF *LevelLayerF::layer_as<flat::resources::ObjectLayerF>() const {
  return layer_as_ObjectLayerF();
}

struct LevelLayerFBuilder {
  typedef LevelLayerF Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(LevelLayerF::VT_ID, id, 0);
  }
  void add_layer_type(flat::resources::AnyLayerF layer_type) {
    fbb_.AddElement<uint8_t>(LevelLayerF::VT_LAYER_TYPE, static_cast<uint8_t>(layer_type), 0);
  }
  void add_layer(flatbuffers::Offset<void> layer) {
    fbb_.AddOffset(LevelLayerF::VT_LAYER, layer);
  }
  void add_properties(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::resources::PropertyF>>> properties) {
    fbb_.AddOffset(LevelLayerF::VT_PROPERTIES, properties);
  }
  explicit LevelLayerFBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LevelLayerF> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LevelLayerF>(end);
    return o;
  }
};

inline flatbuffers::Offset<LevelLayerF> CreateLevelLayerF(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    flat::resources::AnyLayerF layer_type = flat::resources::AnyLayerF_NONE,
    flatbuffers::Offset<void> layer = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::resources::PropertyF>>> properties = 0) {
  LevelLayerFBuilder builder_(_fbb);
  builder_.add_properties(properties);
  builder_.add_layer(layer);
  builder_.add_id(id);
  builder_.add_layer_type(layer_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<LevelLayerF> CreateLevelLayerFDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    flat::resources::AnyLayerF layer_type = flat::resources::AnyLayerF_NONE,
    flatbuffers::Offset<void> layer = 0,
    const std::vector<flatbuffers::Offset<flat::resources::PropertyF>> *properties = nullptr) {
  auto properties__ = properties ? _fbb.CreateVector<flatbuffers::Offset<flat::resources::PropertyF>>(*properties) : 0;
  return flat::resources::CreateLevelLayerF(
      _fbb,
      id,
      layer_type,
      layer,
      properties__);
}

struct LevelTilesetDepF FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LevelTilesetDepFBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GID = 4,
    VT_TILESET_NAME = 6
  };
  uint32_t gid() const {
    return GetField<uint32_t>(VT_GID, 0);
  }
  const flatbuffers::String *tileset_name() const {
    return GetPointer<const flatbuffers::String *>(VT_TILESET_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_GID) &&
           VerifyOffset(verifier, VT_TILESET_NAME) &&
           verifier.VerifyString(tileset_name()) &&
           verifier.EndTable();
  }
};

struct LevelTilesetDepFBuilder {
  typedef LevelTilesetDepF Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_gid(uint32_t gid) {
    fbb_.AddElement<uint32_t>(LevelTilesetDepF::VT_GID, gid, 0);
  }
  void add_tileset_name(flatbuffers::Offset<flatbuffers::String> tileset_name) {
    fbb_.AddOffset(LevelTilesetDepF::VT_TILESET_NAME, tileset_name);
  }
  explicit LevelTilesetDepFBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LevelTilesetDepF> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LevelTilesetDepF>(end);
    return o;
  }
};

inline flatbuffers::Offset<LevelTilesetDepF> CreateLevelTilesetDepF(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t gid = 0,
    flatbuffers::Offset<flatbuffers::String> tileset_name = 0) {
  LevelTilesetDepFBuilder builder_(_fbb);
  builder_.add_tileset_name(tileset_name);
  builder_.add_gid(gid);
  return builder_.Finish();
}

inline flatbuffers::Offset<LevelTilesetDepF> CreateLevelTilesetDepFDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t gid = 0,
    const char *tileset_name = nullptr) {
  auto tileset_name__ = tileset_name ? _fbb.CreateString(tileset_name) : 0;
  return flat::resources::CreateLevelTilesetDepF(
      _fbb,
      gid,
      tileset_name__);
}

struct LevelAssetF FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LevelAssetFBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_BG_COLOR = 6,
    VT_LVL_SIZE = 8,
    VT_LAYERS = 10,
    VT_TILESET_DEPS = 12,
    VT_BORDERS = 14
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  uint32_t bg_color() const {
    return GetField<uint32_t>(VT_BG_COLOR, 0);
  }
  const flat::math::Vec2Fu *lvl_size() const {
    return GetStruct<const flat::math::Vec2Fu *>(VT_LVL_SIZE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flat::resources::LevelLayerF>> *layers() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flat::resources::LevelLayerF>> *>(VT_LAYERS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flat::resources::LevelTilesetDepF>> *tileset_deps() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flat::resources::LevelTilesetDepF>> *>(VT_TILESET_DEPS);
  }
  uint32_t borders() const {
    return GetField<uint32_t>(VT_BORDERS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint32_t>(verifier, VT_BG_COLOR) &&
           VerifyFieldRequired<flat::math::Vec2Fu>(verifier, VT_LVL_SIZE) &&
           VerifyOffset(verifier, VT_LAYERS) &&
           verifier.VerifyVector(layers()) &&
           verifier.VerifyVectorOfTables(layers()) &&
           VerifyOffset(verifier, VT_TILESET_DEPS) &&
           verifier.VerifyVector(tileset_deps()) &&
           verifier.VerifyVectorOfTables(tileset_deps()) &&
           VerifyField<uint32_t>(verifier, VT_BORDERS) &&
           verifier.EndTable();
  }
};

struct LevelAssetFBuilder {
  typedef LevelAssetF Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(LevelAssetF::VT_NAME, name);
  }
  void add_bg_color(uint32_t bg_color) {
    fbb_.AddElement<uint32_t>(LevelAssetF::VT_BG_COLOR, bg_color, 0);
  }
  void add_lvl_size(const flat::math::Vec2Fu *lvl_size) {
    fbb_.AddStruct(LevelAssetF::VT_LVL_SIZE, lvl_size);
  }
  void add_layers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::resources::LevelLayerF>>> layers) {
    fbb_.AddOffset(LevelAssetF::VT_LAYERS, layers);
  }
  void add_tileset_deps(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::resources::LevelTilesetDepF>>> tileset_deps) {
    fbb_.AddOffset(LevelAssetF::VT_TILESET_DEPS, tileset_deps);
  }
  void add_borders(uint32_t borders) {
    fbb_.AddElement<uint32_t>(LevelAssetF::VT_BORDERS, borders, 0);
  }
  explicit LevelAssetFBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LevelAssetF> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LevelAssetF>(end);
    fbb_.Required(o, LevelAssetF::VT_NAME);
    fbb_.Required(o, LevelAssetF::VT_LVL_SIZE);
    return o;
  }
};

inline flatbuffers::Offset<LevelAssetF> CreateLevelAssetF(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    uint32_t bg_color = 0,
    const flat::math::Vec2Fu *lvl_size = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::resources::LevelLayerF>>> layers = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::resources::LevelTilesetDepF>>> tileset_deps = 0,
    uint32_t borders = 0) {
  LevelAssetFBuilder builder_(_fbb);
  builder_.add_borders(borders);
  builder_.add_tileset_deps(tileset_deps);
  builder_.add_layers(layers);
  builder_.add_lvl_size(lvl_size);
  builder_.add_bg_color(bg_color);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<LevelAssetF> CreateLevelAssetFDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    uint32_t bg_color = 0,
    const flat::math::Vec2Fu *lvl_size = 0,
    const std::vector<flatbuffers::Offset<flat::resources::LevelLayerF>> *layers = nullptr,
    const std::vector<flatbuffers::Offset<flat::resources::LevelTilesetDepF>> *tileset_deps = nullptr,
    uint32_t borders = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto layers__ = layers ? _fbb.CreateVector<flatbuffers::Offset<flat::resources::LevelLayerF>>(*layers) : 0;
  auto tileset_deps__ = tileset_deps ? _fbb.CreateVector<flatbuffers::Offset<flat::resources::LevelTilesetDepF>>(*tileset_deps) : 0;
  return flat::resources::CreateLevelAssetF(
      _fbb,
      name__,
      bg_color,
      lvl_size,
      layers__,
      tileset_deps__,
      borders);
}

struct TilesetLogicF FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TilesetLogicFBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LOGIC = 4,
    VT_LOGIC_ARG = 6
  };
  const flatbuffers::String *logic() const {
    return GetPointer<const flatbuffers::String *>(VT_LOGIC);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *logic_arg() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_LOGIC_ARG);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LOGIC) &&
           verifier.VerifyString(logic()) &&
           VerifyOffset(verifier, VT_LOGIC_ARG) &&
           verifier.VerifyVector(logic_arg()) &&
           verifier.VerifyVectorOfStrings(logic_arg()) &&
           verifier.EndTable();
  }
};

struct TilesetLogicFBuilder {
  typedef TilesetLogicF Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_logic(flatbuffers::Offset<flatbuffers::String> logic) {
    fbb_.AddOffset(TilesetLogicF::VT_LOGIC, logic);
  }
  void add_logic_arg(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> logic_arg) {
    fbb_.AddOffset(TilesetLogicF::VT_LOGIC_ARG, logic_arg);
  }
  explicit TilesetLogicFBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TilesetLogicF> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TilesetLogicF>(end);
    fbb_.Required(o, TilesetLogicF::VT_LOGIC);
    return o;
  }
};

inline flatbuffers::Offset<TilesetLogicF> CreateTilesetLogicF(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> logic = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> logic_arg = 0) {
  TilesetLogicFBuilder builder_(_fbb);
  builder_.add_logic_arg(logic_arg);
  builder_.add_logic(logic);
  return builder_.Finish();
}

inline flatbuffers::Offset<TilesetLogicF> CreateTilesetLogicFDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *logic = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *logic_arg = nullptr) {
  auto logic__ = logic ? _fbb.CreateString(logic) : 0;
  auto logic_arg__ = logic_arg ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*logic_arg) : 0;
  return flat::resources::CreateTilesetLogicF(
      _fbb,
      logic__,
      logic_arg__);
}

struct TilesetAssetF FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TilesetAssetFBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_TILE_SIZE = 6,
    VT_TILE_DATA = 8,
    VT_TILESETS = 10,
    VT_MATERIALS = 12,
    VT_LOGICS = 14,
    VT_IMAGE = 16
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flat::math::Vec2Fu *tile_size() const {
    return GetStruct<const flat::math::Vec2Fu *>(VT_TILE_SIZE);
  }
  const flatbuffers::Vector<const flat::resources::TileDataF *> *tile_data() const {
    return GetPointer<const flatbuffers::Vector<const flat::resources::TileDataF *> *>(VT_TILE_DATA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *tilesets() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_TILESETS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *materials() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_MATERIALS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flat::resources::TilesetLogicF>> *logics() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flat::resources::TilesetLogicF>> *>(VT_LOGICS);
  }
  const flatbuffers::Vector<int8_t> *image() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_IMAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyFieldRequired<flat::math::Vec2Fu>(verifier, VT_TILE_SIZE) &&
           VerifyOffset(verifier, VT_TILE_DATA) &&
           verifier.VerifyVector(tile_data()) &&
           VerifyOffset(verifier, VT_TILESETS) &&
           verifier.VerifyVector(tilesets()) &&
           verifier.VerifyVectorOfStrings(tilesets()) &&
           VerifyOffset(verifier, VT_MATERIALS) &&
           verifier.VerifyVector(materials()) &&
           verifier.VerifyVectorOfStrings(materials()) &&
           VerifyOffset(verifier, VT_LOGICS) &&
           verifier.VerifyVector(logics()) &&
           verifier.VerifyVectorOfTables(logics()) &&
           VerifyOffsetRequired(verifier, VT_IMAGE) &&
           verifier.VerifyVector(image()) &&
           verifier.EndTable();
  }
};

struct TilesetAssetFBuilder {
  typedef TilesetAssetF Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(TilesetAssetF::VT_NAME, name);
  }
  void add_tile_size(const flat::math::Vec2Fu *tile_size) {
    fbb_.AddStruct(TilesetAssetF::VT_TILE_SIZE, tile_size);
  }
  void add_tile_data(flatbuffers::Offset<flatbuffers::Vector<const flat::resources::TileDataF *>> tile_data) {
    fbb_.AddOffset(TilesetAssetF::VT_TILE_DATA, tile_data);
  }
  void add_tilesets(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> tilesets) {
    fbb_.AddOffset(TilesetAssetF::VT_TILESETS, tilesets);
  }
  void add_materials(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> materials) {
    fbb_.AddOffset(TilesetAssetF::VT_MATERIALS, materials);
  }
  void add_logics(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::resources::TilesetLogicF>>> logics) {
    fbb_.AddOffset(TilesetAssetF::VT_LOGICS, logics);
  }
  void add_image(flatbuffers::Offset<flatbuffers::Vector<int8_t>> image) {
    fbb_.AddOffset(TilesetAssetF::VT_IMAGE, image);
  }
  explicit TilesetAssetFBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TilesetAssetF> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TilesetAssetF>(end);
    fbb_.Required(o, TilesetAssetF::VT_NAME);
    fbb_.Required(o, TilesetAssetF::VT_TILE_SIZE);
    fbb_.Required(o, TilesetAssetF::VT_IMAGE);
    return o;
  }
};

inline flatbuffers::Offset<TilesetAssetF> CreateTilesetAssetF(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    const flat::math::Vec2Fu *tile_size = 0,
    flatbuffers::Offset<flatbuffers::Vector<const flat::resources::TileDataF *>> tile_data = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> tilesets = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> materials = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::resources::TilesetLogicF>>> logics = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> image = 0) {
  TilesetAssetFBuilder builder_(_fbb);
  builder_.add_image(image);
  builder_.add_logics(logics);
  builder_.add_materials(materials);
  builder_.add_tilesets(tilesets);
  builder_.add_tile_data(tile_data);
  builder_.add_tile_size(tile_size);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<TilesetAssetF> CreateTilesetAssetFDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const flat::math::Vec2Fu *tile_size = 0,
    const std::vector<flat::resources::TileDataF> *tile_data = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *tilesets = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *materials = nullptr,
    const std::vector<flatbuffers::Offset<flat::resources::TilesetLogicF>> *logics = nullptr,
    const std::vector<int8_t> *image = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto tile_data__ = tile_data ? _fbb.CreateVectorOfStructs<flat::resources::TileDataF>(*tile_data) : 0;
  auto tilesets__ = tilesets ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*tilesets) : 0;
  auto materials__ = materials ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*materials) : 0;
  auto logics__ = logics ? _fbb.CreateVector<flatbuffers::Offset<flat::resources::TilesetLogicF>>(*logics) : 0;
  auto image__ = image ? _fbb.CreateVector<int8_t>(*image) : 0;
  return flat::resources::CreateTilesetAssetF(
      _fbb,
      name__,
      tile_size,
      tile_data__,
      tilesets__,
      materials__,
      logics__,
      image__);
}

struct AnimationAssetF FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AnimationAssetFBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_AREA = 6,
    VT_ORIGIN = 8,
    VT_FRAMERATE_MS = 10,
    VT_LOOP = 12,
    VT_HAS_CHAIN = 14,
    VT_CHAIN_SPR_NAME = 16,
    VT_CHAIN_ANIM_NAME = 18,
    VT_CHAIN_FRAME = 20
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flat::math::RectFi *area() const {
    return GetStruct<const flat::math::RectFi *>(VT_AREA);
  }
  const flat::math::Vec2Fi *origin() const {
    return GetStruct<const flat::math::Vec2Fi *>(VT_ORIGIN);
  }
  const flatbuffers::Vector<uint32_t> *framerate_ms() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_FRAMERATE_MS);
  }
  uint32_t loop() const {
    return GetField<uint32_t>(VT_LOOP, 0);
  }
  bool has_chain() const {
    return GetField<uint8_t>(VT_HAS_CHAIN, 0) != 0;
  }
  const flatbuffers::String *chain_spr_name() const {
    return GetPointer<const flatbuffers::String *>(VT_CHAIN_SPR_NAME);
  }
  const flatbuffers::String *chain_anim_name() const {
    return GetPointer<const flatbuffers::String *>(VT_CHAIN_ANIM_NAME);
  }
  uint32_t chain_frame() const {
    return GetField<uint32_t>(VT_CHAIN_FRAME, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyFieldRequired<flat::math::RectFi>(verifier, VT_AREA) &&
           VerifyFieldRequired<flat::math::Vec2Fi>(verifier, VT_ORIGIN) &&
           VerifyOffsetRequired(verifier, VT_FRAMERATE_MS) &&
           verifier.VerifyVector(framerate_ms()) &&
           VerifyField<uint32_t>(verifier, VT_LOOP) &&
           VerifyField<uint8_t>(verifier, VT_HAS_CHAIN) &&
           VerifyOffset(verifier, VT_CHAIN_SPR_NAME) &&
           verifier.VerifyString(chain_spr_name()) &&
           VerifyOffset(verifier, VT_CHAIN_ANIM_NAME) &&
           verifier.VerifyString(chain_anim_name()) &&
           VerifyField<uint32_t>(verifier, VT_CHAIN_FRAME) &&
           verifier.EndTable();
  }
};

struct AnimationAssetFBuilder {
  typedef AnimationAssetF Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(AnimationAssetF::VT_NAME, name);
  }
  void add_area(const flat::math::RectFi *area) {
    fbb_.AddStruct(AnimationAssetF::VT_AREA, area);
  }
  void add_origin(const flat::math::Vec2Fi *origin) {
    fbb_.AddStruct(AnimationAssetF::VT_ORIGIN, origin);
  }
  void add_framerate_ms(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> framerate_ms) {
    fbb_.AddOffset(AnimationAssetF::VT_FRAMERATE_MS, framerate_ms);
  }
  void add_loop(uint32_t loop) {
    fbb_.AddElement<uint32_t>(AnimationAssetF::VT_LOOP, loop, 0);
  }
  void add_has_chain(bool has_chain) {
    fbb_.AddElement<uint8_t>(AnimationAssetF::VT_HAS_CHAIN, static_cast<uint8_t>(has_chain), 0);
  }
  void add_chain_spr_name(flatbuffers::Offset<flatbuffers::String> chain_spr_name) {
    fbb_.AddOffset(AnimationAssetF::VT_CHAIN_SPR_NAME, chain_spr_name);
  }
  void add_chain_anim_name(flatbuffers::Offset<flatbuffers::String> chain_anim_name) {
    fbb_.AddOffset(AnimationAssetF::VT_CHAIN_ANIM_NAME, chain_anim_name);
  }
  void add_chain_frame(uint32_t chain_frame) {
    fbb_.AddElement<uint32_t>(AnimationAssetF::VT_CHAIN_FRAME, chain_frame, 0);
  }
  explicit AnimationAssetFBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AnimationAssetF> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AnimationAssetF>(end);
    fbb_.Required(o, AnimationAssetF::VT_NAME);
    fbb_.Required(o, AnimationAssetF::VT_AREA);
    fbb_.Required(o, AnimationAssetF::VT_ORIGIN);
    fbb_.Required(o, AnimationAssetF::VT_FRAMERATE_MS);
    return o;
  }
};

inline flatbuffers::Offset<AnimationAssetF> CreateAnimationAssetF(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    const flat::math::RectFi *area = 0,
    const flat::math::Vec2Fi *origin = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> framerate_ms = 0,
    uint32_t loop = 0,
    bool has_chain = false,
    flatbuffers::Offset<flatbuffers::String> chain_spr_name = 0,
    flatbuffers::Offset<flatbuffers::String> chain_anim_name = 0,
    uint32_t chain_frame = 0) {
  AnimationAssetFBuilder builder_(_fbb);
  builder_.add_chain_frame(chain_frame);
  builder_.add_chain_anim_name(chain_anim_name);
  builder_.add_chain_spr_name(chain_spr_name);
  builder_.add_loop(loop);
  builder_.add_framerate_ms(framerate_ms);
  builder_.add_origin(origin);
  builder_.add_area(area);
  builder_.add_name(name);
  builder_.add_has_chain(has_chain);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnimationAssetF> CreateAnimationAssetFDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const flat::math::RectFi *area = 0,
    const flat::math::Vec2Fi *origin = 0,
    const std::vector<uint32_t> *framerate_ms = nullptr,
    uint32_t loop = 0,
    bool has_chain = false,
    const char *chain_spr_name = nullptr,
    const char *chain_anim_name = nullptr,
    uint32_t chain_frame = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto framerate_ms__ = framerate_ms ? _fbb.CreateVector<uint32_t>(*framerate_ms) : 0;
  auto chain_spr_name__ = chain_spr_name ? _fbb.CreateString(chain_spr_name) : 0;
  auto chain_anim_name__ = chain_anim_name ? _fbb.CreateString(chain_anim_name) : 0;
  return flat::resources::CreateAnimationAssetF(
      _fbb,
      name__,
      area,
      origin,
      framerate_ms__,
      loop,
      has_chain,
      chain_spr_name__,
      chain_anim_name__,
      chain_frame);
}

struct SpriteAssetF FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SpriteAssetFBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_ANIMATIONS = 6,
    VT_IMAGE = 8
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flat::resources::AnimationAssetF>> *animations() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flat::resources::AnimationAssetF>> *>(VT_ANIMATIONS);
  }
  const flatbuffers::Vector<int8_t> *image() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_IMAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_ANIMATIONS) &&
           verifier.VerifyVector(animations()) &&
           verifier.VerifyVectorOfTables(animations()) &&
           VerifyOffsetRequired(verifier, VT_IMAGE) &&
           verifier.VerifyVector(image()) &&
           verifier.EndTable();
  }
};

struct SpriteAssetFBuilder {
  typedef SpriteAssetF Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(SpriteAssetF::VT_NAME, name);
  }
  void add_animations(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::resources::AnimationAssetF>>> animations) {
    fbb_.AddOffset(SpriteAssetF::VT_ANIMATIONS, animations);
  }
  void add_image(flatbuffers::Offset<flatbuffers::Vector<int8_t>> image) {
    fbb_.AddOffset(SpriteAssetF::VT_IMAGE, image);
  }
  explicit SpriteAssetFBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SpriteAssetF> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SpriteAssetF>(end);
    fbb_.Required(o, SpriteAssetF::VT_NAME);
    fbb_.Required(o, SpriteAssetF::VT_IMAGE);
    return o;
  }
};

inline flatbuffers::Offset<SpriteAssetF> CreateSpriteAssetF(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::resources::AnimationAssetF>>> animations = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> image = 0) {
  SpriteAssetFBuilder builder_(_fbb);
  builder_.add_image(image);
  builder_.add_animations(animations);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<SpriteAssetF> CreateSpriteAssetFDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<flatbuffers::Offset<flat::resources::AnimationAssetF>> *animations = nullptr,
    const std::vector<int8_t> *image = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto animations__ = animations ? _fbb.CreateVector<flatbuffers::Offset<flat::resources::AnimationAssetF>>(*animations) : 0;
  auto image__ = image ? _fbb.CreateVector<int8_t>(*image) : 0;
  return flat::resources::CreateSpriteAssetF(
      _fbb,
      name__,
      animations__,
      image__);
}

struct ResourcesF FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ResourcesFBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SPRITES = 4,
    VT_TILESETS = 6,
    VT_LEVELS = 8
  };
  const flatbuffers::Vector<flatbuffers::Offset<flat::resources::SpriteAssetF>> *sprites() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flat::resources::SpriteAssetF>> *>(VT_SPRITES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flat::resources::TilesetAssetF>> *tilesets() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flat::resources::TilesetAssetF>> *>(VT_TILESETS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flat::resources::LevelAssetF>> *levels() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flat::resources::LevelAssetF>> *>(VT_LEVELS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SPRITES) &&
           verifier.VerifyVector(sprites()) &&
           verifier.VerifyVectorOfTables(sprites()) &&
           VerifyOffset(verifier, VT_TILESETS) &&
           verifier.VerifyVector(tilesets()) &&
           verifier.VerifyVectorOfTables(tilesets()) &&
           VerifyOffset(verifier, VT_LEVELS) &&
           verifier.VerifyVector(levels()) &&
           verifier.VerifyVectorOfTables(levels()) &&
           verifier.EndTable();
  }
};

struct ResourcesFBuilder {
  typedef ResourcesF Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_sprites(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::resources::SpriteAssetF>>> sprites) {
    fbb_.AddOffset(ResourcesF::VT_SPRITES, sprites);
  }
  void add_tilesets(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::resources::TilesetAssetF>>> tilesets) {
    fbb_.AddOffset(ResourcesF::VT_TILESETS, tilesets);
  }
  void add_levels(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::resources::LevelAssetF>>> levels) {
    fbb_.AddOffset(ResourcesF::VT_LEVELS, levels);
  }
  explicit ResourcesFBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ResourcesF> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ResourcesF>(end);
    return o;
  }
};

inline flatbuffers::Offset<ResourcesF> CreateResourcesF(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::resources::SpriteAssetF>>> sprites = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::resources::TilesetAssetF>>> tilesets = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flat::resources::LevelAssetF>>> levels = 0) {
  ResourcesFBuilder builder_(_fbb);
  builder_.add_levels(levels);
  builder_.add_tilesets(tilesets);
  builder_.add_sprites(sprites);
  return builder_.Finish();
}

inline flatbuffers::Offset<ResourcesF> CreateResourcesFDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<flat::resources::SpriteAssetF>> *sprites = nullptr,
    const std::vector<flatbuffers::Offset<flat::resources::TilesetAssetF>> *tilesets = nullptr,
    const std::vector<flatbuffers::Offset<flat::resources::LevelAssetF>> *levels = nullptr) {
  auto sprites__ = sprites ? _fbb.CreateVector<flatbuffers::Offset<flat::resources::SpriteAssetF>>(*sprites) : 0;
  auto tilesets__ = tilesets ? _fbb.CreateVector<flatbuffers::Offset<flat::resources::TilesetAssetF>>(*tilesets) : 0;
  auto levels__ = levels ? _fbb.CreateVector<flatbuffers::Offset<flat::resources::LevelAssetF>>(*levels) : 0;
  return flat::resources::CreateResourcesF(
      _fbb,
      sprites__,
      tilesets__,
      levels__);
}

inline bool VerifyAnyLayerF(flatbuffers::Verifier &verifier, const void *obj, AnyLayerF type) {
  switch (type) {
    case AnyLayerF_NONE: {
      return true;
    }
    case AnyLayerF_TileLayerF: {
      auto ptr = reinterpret_cast<const flat::resources::TileLayerF *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyLayerF_ObjectLayerF: {
      auto ptr = reinterpret_cast<const flat::resources::ObjectLayerF *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyAnyLayerFVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyAnyLayerF(
        verifier,  values->Get(i), types->GetEnum<AnyLayerF>(i))) {
      return false;
    }
  }
  return true;
}

inline const flat::resources::ResourcesF *GetResourcesF(const void *buf) {
  return flatbuffers::GetRoot<flat::resources::ResourcesF>(buf);
}

inline const flat::resources::ResourcesF *GetSizePrefixedResourcesF(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<flat::resources::ResourcesF>(buf);
}

inline const char *ResourcesFIdentifier() {
  return "PACK";
}

inline bool ResourcesFBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, ResourcesFIdentifier());
}

inline bool VerifyResourcesFBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<flat::resources::ResourcesF>(ResourcesFIdentifier());
}

inline bool VerifySizePrefixedResourcesFBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<flat::resources::ResourcesF>(ResourcesFIdentifier());
}

inline const char *ResourcesFExtension() {
  return "pack";
}

inline void FinishResourcesFBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<flat::resources::ResourcesF> root) {
  fbb.Finish(root, ResourcesFIdentifier());
}

inline void FinishSizePrefixedResourcesFBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<flat::resources::ResourcesF> root) {
  fbb.FinishSizePrefixed(root, ResourcesFIdentifier());
}

}  // namespace resources
}  // namespace flat

#endif  // FLATBUFFERS_GENERATED_RESOURCE_FLAT_RESOURCES_H_
