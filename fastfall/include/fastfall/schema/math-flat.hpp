// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MATH_FLAT_MATH_H_
#define FLATBUFFERS_GENERATED_MATH_FLAT_MATH_H_

#include "flatbuffers/flatbuffers.h"

namespace flat {
namespace math {

struct Vec2Fi;

struct Vec2Ff;

struct Vec2Fu;

struct LineFi;

struct LineFf;

struct RectFi;

struct RectFf;

enum CardinalF {
  CardinalF_NORTH = 0,
  CardinalF_EAST = 1,
  CardinalF_SOUTH = 2,
  CardinalF_WEST = 3,
  CardinalF_MIN = CardinalF_NORTH,
  CardinalF_MAX = CardinalF_WEST
};

inline const CardinalF (&EnumValuesCardinalF())[4] {
  static const CardinalF values[] = {
    CardinalF_NORTH,
    CardinalF_EAST,
    CardinalF_SOUTH,
    CardinalF_WEST
  };
  return values;
}

inline const char * const *EnumNamesCardinalF() {
  static const char * const names[5] = {
    "NORTH",
    "EAST",
    "SOUTH",
    "WEST",
    nullptr
  };
  return names;
}

inline const char *EnumNameCardinalF(CardinalF e) {
  if (flatbuffers::IsOutRange(e, CardinalF_NORTH, CardinalF_WEST)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCardinalF()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec2Fi FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t x_;
  int32_t y_;

 public:
  Vec2Fi() {
    memset(static_cast<void *>(this), 0, sizeof(Vec2Fi));
  }
  Vec2Fi(int32_t _x, int32_t _y)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  int32_t x() const {
    return flatbuffers::EndianScalar(x_);
  }
  int32_t y() const {
    return flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(Vec2Fi, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec2Ff FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  Vec2Ff() {
    memset(static_cast<void *>(this), 0, sizeof(Vec2Ff));
  }
  Vec2Ff(float _x, float _y)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(Vec2Ff, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec2Fu FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t x_;
  uint32_t y_;

 public:
  Vec2Fu() {
    memset(static_cast<void *>(this), 0, sizeof(Vec2Fu));
  }
  Vec2Fu(uint32_t _x, uint32_t _y)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  uint32_t x() const {
    return flatbuffers::EndianScalar(x_);
  }
  uint32_t y() const {
    return flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(Vec2Fu, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) LineFi FLATBUFFERS_FINAL_CLASS {
 private:
  flat::math::Vec2Fi p1_;
  flat::math::Vec2Fi p2_;

 public:
  LineFi() {
    memset(static_cast<void *>(this), 0, sizeof(LineFi));
  }
  LineFi(const flat::math::Vec2Fi &_p1, const flat::math::Vec2Fi &_p2)
      : p1_(_p1),
        p2_(_p2) {
  }
  const flat::math::Vec2Fi &p1() const {
    return p1_;
  }
  const flat::math::Vec2Fi &p2() const {
    return p2_;
  }
};
FLATBUFFERS_STRUCT_END(LineFi, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) LineFf FLATBUFFERS_FINAL_CLASS {
 private:
  flat::math::Vec2Ff p1_;
  flat::math::Vec2Ff p2_;

 public:
  LineFf() {
    memset(static_cast<void *>(this), 0, sizeof(LineFf));
  }
  LineFf(const flat::math::Vec2Ff &_p1, const flat::math::Vec2Ff &_p2)
      : p1_(_p1),
        p2_(_p2) {
  }
  const flat::math::Vec2Ff &p1() const {
    return p1_;
  }
  const flat::math::Vec2Ff &p2() const {
    return p2_;
  }
};
FLATBUFFERS_STRUCT_END(LineFf, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) RectFi FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t left_;
  int32_t top_;
  int32_t width_;
  int32_t height_;

 public:
  RectFi() {
    memset(static_cast<void *>(this), 0, sizeof(RectFi));
  }
  RectFi(int32_t _left, int32_t _top, int32_t _width, int32_t _height)
      : left_(flatbuffers::EndianScalar(_left)),
        top_(flatbuffers::EndianScalar(_top)),
        width_(flatbuffers::EndianScalar(_width)),
        height_(flatbuffers::EndianScalar(_height)) {
  }
  int32_t left() const {
    return flatbuffers::EndianScalar(left_);
  }
  int32_t top() const {
    return flatbuffers::EndianScalar(top_);
  }
  int32_t width() const {
    return flatbuffers::EndianScalar(width_);
  }
  int32_t height() const {
    return flatbuffers::EndianScalar(height_);
  }
};
FLATBUFFERS_STRUCT_END(RectFi, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) RectFf FLATBUFFERS_FINAL_CLASS {
 private:
  float left_;
  float top_;
  float width_;
  float height_;

 public:
  RectFf() {
    memset(static_cast<void *>(this), 0, sizeof(RectFf));
  }
  RectFf(float _left, float _top, float _width, float _height)
      : left_(flatbuffers::EndianScalar(_left)),
        top_(flatbuffers::EndianScalar(_top)),
        width_(flatbuffers::EndianScalar(_width)),
        height_(flatbuffers::EndianScalar(_height)) {
  }
  float left() const {
    return flatbuffers::EndianScalar(left_);
  }
  float top() const {
    return flatbuffers::EndianScalar(top_);
  }
  float width() const {
    return flatbuffers::EndianScalar(width_);
  }
  float height() const {
    return flatbuffers::EndianScalar(height_);
  }
};
FLATBUFFERS_STRUCT_END(RectFf, 16);

}  // namespace math
}  // namespace flat

#endif  // FLATBUFFERS_GENERATED_MATH_FLAT_MATH_H_
